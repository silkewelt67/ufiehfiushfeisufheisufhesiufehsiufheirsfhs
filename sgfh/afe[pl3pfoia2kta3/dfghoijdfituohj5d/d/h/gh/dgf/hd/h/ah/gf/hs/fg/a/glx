warn("r")
warn("adoniscries bypass:")
loadstring(game:HttpGet("https://raw.githubusercontent.com/Pixeluted/adoniscries/refs/heads/main/Source.lua"))()
warn("done adonis...")
local funcsToLoad = {}
local autoFuncId = 0

function registerFuncAuto(fn)
    autoFuncId = autoFuncId + 1
    funcsToLoad[#funcsToLoad + 1] = {name="func"..autoFuncId, fn=fn}
end

function loadfunc()
    for _, f in ipairs(funcsToLoad) do
        f.fn()
    end
end

registerFuncAuto(function()

print('\n')
print('\n')
print('\n')
print('file imports \n')
files = loadstring(game:HttpGet("https://raw.githubusercontent.com/petal-cymk/assets/refs/heads/main/import.lua"))()
files.import("logo.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/_peak.png")
files.import("visual.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/download%20(3)%20(1)%20(1).png")
files.import("combat.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/maio%20%F0%9F%90%B1%20(1).png")
files.import("player.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/download%20(4)%20(1)%20(1).png")
files.import("world.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/download%20(5)%20(1).png")
files.import("settings.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/download%20(6).png")

print('break \n')
print('\n')
print('\n')
print('\n')
repo='https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/'

Library=loadstring(game:HttpGet('https://codeberg.org/fuse/ch/raw/branch/main/lib.lua'))()

if getgenv().GG_LOADED then
    Library:Notify({
        Title = "RuntimeException: ScriptExecutionViolation",
        Description = "Script already loaded in runtime; detected at line :40.\nExecution context already active.\nSet getgenv().GG_LOADED = false to override this safeguard.",
        Time = 6
    })
    task.wait(9e9)
end
getgenv().GG_LOADED = true

local success, e = pcall(IdentifyExecutor)

if success then
    if e ~= "Xeno" then
        Library:Notify({
            Title = "RuntimeNotify: Executor",
            Description = e .. " is extremely unstable. Although it is supported, it is far from recommended.",
            Time = 6
        })
    end
else
    local xenoSuccess = pcall(function() return Xeno.about end)
    if xenoSuccess then
        Library:Notify({
            Title = "RuntimeNotify: Executor",
            Description = "Xeno is extremely unstable. Although it is supported, it is far from recommended.",
            Time = 6
        })
    end
end

games = {
    town = false,
    projectdelta = false,
}

local name = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name:lower()
UNIVERSAL = true

if name:find("project") or name:find("estonia") or name:find("city") then
    UNIVERSAL = false
    games.projectdelta = true
end

if name:find("town") then
    games.town = true
end

function pcallCheck(func)
    if not UNIVERSAL then
        local success, result = pcall(func)
        return success, result
    end
end

pcallCheck(function()
end)

ThemeManager=loadstring(game:HttpGet(repo..'addons/ThemeManager.lua'))()
SaveManager=loadstring(game:HttpGet(repo..'addons/SaveManager.lua'))()
Options = Library.Options
Toggles = Library.Toggles
current_load = 0
max_load = 7
Library.ForceCheckbox = true


function notifyl(section, type)
    current_load = current_load + 1
    local description = string.format("%d / %d | %s", current_load, max_load, type)
    Library:Notify({
        Title = section,
        Description = description,
        Time = 5,
    })
    print(string.format("%d / %d | %s %s loaded.\n", current_load, max_load, section, type))
end

function finishLoading()
    local description = "finished loading solutions.gg."
    Library:Notify({
        Title = string.format("%d / %d", max_load, max_load),
        Description = description,
        Time = 5,
    })
    print(string.format("%d / %d | %s\n", max_load, max_load, description))
end

local RunService = game:GetService("RunService")

pcallCheck(function()
local Camera = workspace:WaitForChild("Camera")
end)

local armsColor = Color3.new(1,1,1)
local weaponColor = Color3.new(1,1,1)
local highlightFill = Color3.new(1,1,1)
local highlightOutline = Color3.new(1,1,1)

local overrideVM = false
local overrideArms = false
setfflag("AdornShadingAPI", "true")
local overrideWeapon = false
local armsMat = Enum.Material.SmoothPlastic
local weaponMat = Enum.Material.SmoothPlastic
local armsTrans = 0
local weaponTrans = 0
local hlEnabled = false
local hlFillTrans = 0
local hlOutlineTrans = 0

local function getParts(vm)
pcallCheck(function()
    local arms = {}
    local weapon = {}
    local item = vm:FindFirstChild("Item")

    for _,v in ipairs(vm:GetDescendants()) do
        if v:IsA("BasePart") then
            if item and v:IsDescendantOf(item) then
                table.insert(weapon,v)
            else
                table.insert(arms,v)
            end
        end
    end

    return arms, weapon
    end)
end

local function apply(vm)
    pcallCheck(function()
    if not overrideVM or not vm then return end

    for _,v in ipairs(vm:GetDescendants()) do
        if v:IsA("BasePart") then
            for _,sa in ipairs(v:GetChildren()) do
                if sa:IsA("SurfaceAppearance") then
                    sa:Destroy()
                end
            end
        end
    end

    local arms, weapon = getParts(vm)

    if overrideArms then
        for _,p in ipairs(arms) do
            if p.Transparency < 0.99 then
                p.Color = armsColor
                p.Material = armsMat
                p.Transparency = armsTrans
            end
        end
    end

    if overrideWeapon then
        for _,p in ipairs(weapon) do
            if p.Transparency < 0.99 then
                p.Color = weaponColor
                p.Material = weaponMat
                p.Transparency = weaponTrans
            end
        end
    end

    if hlEnabled then
        local h = vm:FindFirstChild("VMHighlight") or Instance.new("Highlight", vm)
        h.Name = "VMHighlight"
        h.FillColor = highlightFill
        h.OutlineColor = highlightOutline
        h.FillTransparency = math.clamp(hlFillTrans, -20, 20)
        h.OutlineTransparency = math.clamp(hlOutlineTrans, 0, 1)
    else
        local h = vm:FindFirstChild("VMHighlight")
        if h then h:Destroy() end
    end
    end)
end

spawn(function()
pcallCheck(function()
    while true do
        local vm = Camera:FindFirstChild("ViewModel")
        if vm then
            apply(vm)
        end
        wait(0.05)
    end
end)
end)


targeting_flags = {
    enabled = false,
    mitarget = false,
    bandit_target = false,
    boss_target = false,
    fov_radius = 200,
    gradient_rot = 0,
    col_a = Color3.fromRGB(255,255,255),
    col_b = Color3.fromRGB(255,255,255),
    render_inner = true,
    render_middle = true,
    render_outline = true,
    target_players = true
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local LocalPlayer = Players.LocalPlayer
local Mouse = Players.LocalPlayer:GetMouse()

local gui = Instance.new("ScreenGui", CoreGui)
gui.Name = "FOV_Circle_GUI"

local fov = Instance.new("Frame", gui)
fov.Size = UDim2.new(0, targeting_flags.fov_radius, 0, targeting_flags.fov_radius)
fov.Position = UDim2.new(0.5,0,0.5,0)
fov.AnchorPoint = Vector2.new(0.5,0.5)
fov.BackgroundTransparency = 1
fov.BorderSizePixel = 0
fov.Visible = targeting_flags.enabled

local corner = Instance.new("UICorner", fov)
corner.CornerRadius = UDim.new(1,8)

local stroke_inner = Instance.new("UIStroke", fov)
stroke_inner.Thickness = 1
stroke_inner.Color = Color3.new(0,0,0)
stroke_inner.ZIndex = 1
stroke_inner.Enabled = targeting_flags.render_inner

local fillStroke = Instance.new("UIStroke", fov)
fillStroke.Thickness = 1.5
fillStroke.Color = Color3.new(1,1,1)
fillStroke.BorderOffset = UDim.new(0,1)
fillStroke.ZIndex = 1
fillStroke.Enabled = targeting_flags.render_middle

local gradient = Instance.new("UIGradient", fillStroke)
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, targeting_flags.col_a),
    ColorSequenceKeypoint.new(1, targeting_flags.col_b)
}
gradient.Rotation = targeting_flags.gradient_rot

local outlineStroke = Instance.new("UIStroke", fov)
outlineStroke.Thickness = 1
outlineStroke.Color = Color3.new(0,0,0)
outlineStroke.BorderOffset = UDim.new(0,2.5)
outlineStroke.ZIndex = 2
outlineStroke.Enabled = targeting_flags.render_outline

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

plr_target = nil

RunService.RenderStepped:Connect(function()
    if not targeting_flags.enabled then
        plr_target = nil
        return
    end

    local closest = nil
    local shortest = targeting_flags.fov_radius

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and targeting_flags.target_players then
            local char = plr.Character
            local head = char and char:FindFirstChild("Head")
            local hum = char and char:FindFirstChild("Humanoid")
            if head and hum and hum.Health > 0 then
                local pos, onscreen = workspace.CurrentCamera:WorldToViewportPoint(head.Position)
                if onscreen then
                    local dist = (Vector2.new(pos.X,pos.Y) - Vector2.new(Mouse.X,Mouse.Y)).Magnitude
                    if dist < shortest then
                        shortest = dist
                        closest = plr.Name
                    end
                end
            end
        end
    end

    if targeting_flags.mitarget then
        pcallCheck(function()
        local mi24 =
            workspace:FindFirstChild("AiZones")
            and workspace.AiZones:FindFirstChild("HeliAirfield")
            and workspace.AiZones.HeliAirfield:FindFirstChild("MI24V")
            and workspace.AiZones.HeliAirfield.MI24V:FindFirstChild("Pilots")
            and workspace.AiZones.HeliAirfield.MI24V.Pilots:FindFirstChild("CollisionPilot")

        if mi24 then
            local pos, onscreen = workspace.CurrentCamera:WorldToViewportPoint(mi24.Position)
            if onscreen then
                local dist = (Vector2.new(pos.X,pos.Y) - Vector2.new(Mouse.X,Mouse.Y)).Magnitude
                if dist < shortest then
                    shortest = dist
                    closest = "AiZones/HeliAirfield/MI24V/Pilots/CollisionPilot"
                end
            end
        end
    end)
    end

    if targeting_flags.bandit_target or targeting_flags.boss_target then
        pcallCheck(function()
        local aiZones = workspace:FindFirstChild("AiZones")
        if aiZones then
            for _, zone in ipairs(aiZones:GetChildren()) do
                for _, model in ipairs(zone:GetChildren()) do
                    local hrp = model:FindFirstChild("HumanoidRootPart")
                    local hum = model:FindFirstChild("Humanoid")
                    if hrp and hum and hum.Health > 0 then
                        local nameLower = model.Name:lower()
                        local isBandit = nameLower:find("bandit")
                        local targetThis = (isBandit and targeting_flags.bandit_target) or (not isBandit and targeting_flags.boss_target)
                        if targetThis then
                            local pos, onscreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                            if onscreen then
                                local dist = (Vector2.new(pos.X,pos.Y) - Vector2.new(Mouse.X,Mouse.Y)).Magnitude
                                if dist < shortest then
                                    shortest = dist
                                    closest = model.Name
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
    end

    plr_target = closest
end)

local TargetLabel = Library:AddDraggableLabel("target = nil")

local spoofTimer = 0
local spoofActive = false
local spoofTriggered = false

task.spawn(function()
    while task.wait(0.1) do
        local targetName = "nil"
        local color = Color3.fromRGB(255, 255, 255)

        if typeof(plr_target) == "Instance" and plr_target:IsA("BasePart") then
            local character = plr_target.Parent
            if character then
                local player = Players:GetPlayerFromCharacter(character)
                if player then
                    targetName = player.Name
                    color = Color3.fromRGB(0, 255, 0)
                end
            end
        end

        if spoofing then
            spoofTriggered = true
            spoofTimer = 0
            spoofActive = false
        elseif spoofTriggered then
            spoofTimer = spoofTimer + 0.1
            spoofActive = true
        end

        local text = "target = " .. targetName

        if spoofActive then
            text = text .. "\n[" .. math.floor(spoofTimer) .. "] spoofing"
        end

        TargetLabel:SetText(text)
    end
end)

local Players=game:GetService("Players")
local LocalPlayer=Players.LocalPlayer
local Camera=workspace.CurrentCamera
local RunService=game:GetService("RunService")
local HttpService=game:GetService("HttpService")

local Fonts={}
local FontNames={Minecraftia="minecraftia.ttf",Tahoma="fs-tahoma-8px.ttf",Heavy="smallest_pixel-7.ttf"}
local function RegisterFont(Name,Asset)
 if not isfile(Asset.Id) then writefile(Asset.Id,Asset.Font) end
 if isfile(Name..".font") then delfile(Name..".font") end
 local Data={name=Name,faces={{name="Normal",weight=400,style="Normal",assetId=getcustomasset(Asset.Id)}}}
 writefile(Name..".font",HttpService:JSONEncode(Data))
 return getcustomasset(Name..".font")
end
for name,file in pairs(FontNames) do
 local asset=game:HttpGet("https://raw.githubusercontent.com/petal-cymk/assets/main/fonts/"..file)
 Fonts[name]=Font.new(RegisterFont(name,{Id=file,Font=asset}),Enum.FontWeight.Regular,Enum.FontStyle.Normal)
end
local logorb = files.gca("logo.png", "images")

local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")

if not isfolder("SOLUTIONS/assets/images") then
    makefolder("SOLUTIONS/assets/images")
end

local imgPath = "SOLUTIONS/assets/images/solutions.png"

if isfile(imgPath) then
    delfile(imgPath)
end

writefile(imgPath, game:HttpGet("https://raw.githubusercontent.com/petal-cymk/assets/main/Screenshot%202026-01-31%20005934.png"))

SplashGui = Instance.new("ScreenGui")
SplashGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
SplashGui.DisplayOrder = 9999999
SplashGui.Parent = CoreGui
SplashGui.ResetOnSpawn = false
SplashGui.IgnoreGuiInset = true

BlackBG = Instance.new("Frame")
BlackBG.Size = UDim2.new(1,0,1,0)
BlackBG.Position = UDim2.new(0,0,0,0)
BlackBG.BackgroundColor3 = Color3.fromRGB(0,0,0)
BlackBG.BorderSizePixel = 0
BlackBG.Parent = SplashGui
BlackBG.BackgroundTransparency = 1
BlackBG.ZIndex = 9999900000000

Logo = Instance.new("ImageLabel")
Logo.Size = UDim2.new(0, 600, 0, 300)
Logo.AnchorPoint = Vector2.new(0.5,0.5)
Logo.Position = UDim2.new(0.5,0,0.5,0)
Logo.BackgroundTransparency = 1
Logo.Image = getcustomasset(imgPath)
Logo.Parent = SplashGui
Logo.ImageTransparency = 1
Logo.ScaleType = Enum.ScaleType.Fit
Logo.ZIndex = 9999900000001

fadeInBG = TweenService:Create(BlackBG, TweenInfo.new(0.5), {BackgroundTransparency = 0})
fadeInLogo = TweenService:Create(Logo, TweenInfo.new(0.5), {ImageTransparency = 0})

fadeInBG:Play()
task.wait(0.5)
fadeInLogo:Play()
fadeInLogo.Completed:Wait()
task.wait(0.5)

Window = Library:CreateWindow({
	Title = "solutions.gg",
	Footer = "the only real free option.",
	Icon = logorb,
	NotifySide = "Right",
	ShowCustomCursor = true,
})
local visl = files.gca("visual.png", "images")
Tabs={Main=Window:AddTab("Visual", visl)}

ESPSubtab=Tabs.Main:AddLeftTabbox()
SubESP=ESPSubtab:AddTab("ESP")
SubPersonal=ESPSubtab:AddTab("Personalisation")

ChamSubtab=Tabs.Main:AddRightTabbox() 
SubChams=ChamSubtab:AddTab("Chams") 
SubChamsPersonal=ChamSubtab:AddTab("Personalisation")

CrosshairSubtab=Tabs.Main:AddRightTabbox()
Subcross=CrosshairSubtab:AddTab('Crosshair')
SubcrossP=CrosshairSubtab:AddTab("Personalisation")


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local crosshairEnabled = false
local crosshairGap = 10
local crosshairLength = 20
local crosshairWidth = 2
local crosshairSpin = false
local crosshairSpinSpeed = 1
local crosshairOutline = true
local colorStart = Color3.fromRGB(255,255,255)
local colorEnd = Color3.fromRGB(0,0,255)

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "CustomCrosshair"
ScreenGui.Parent = game:GetService("CoreGui")
ScreenGui.IgnoreGuiInset = true

local Crosshair = Instance.new("Frame")
Crosshair.Size = UDim2.new(0,0,0,0)
Crosshair.Position = UDim2.new(0.5,0,0.5,0)
Crosshair.AnchorPoint = Vector2.new(0.5,0.5)
Crosshair.BackgroundTransparency = 1
Crosshair.Parent = ScreenGui

local function createLine(isHorizontal)
    local line = Instance.new("Frame")
    line.BackgroundTransparency = 0
    line.Size = isHorizontal and UDim2.new(0,crosshairLength,0,crosshairWidth) or UDim2.new(0,crosshairWidth,0,crosshairLength)
    line.AnchorPoint = Vector2.new(0.5,0.5)
    line.BackgroundColor3 = colorStart
    line.Parent = Crosshair

    local grad = Instance.new("UIGradient")
    grad.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,colorStart), ColorSequenceKeypoint.new(1,colorEnd)})
    if not isHorizontal then
        grad.Rotation = 90
    end
    grad.Parent = line

    local outline = Instance.new("UIStroke")
    outline.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    outline.Color = Color3.new(0,0,0)
    outline.Thickness = 1
    outline.Enabled = crosshairOutline
    outline.Parent = line

    return line, grad, outline
end

local upLine, upGrad, upOutline = createLine(false)
local downLine, downGrad, downOutline = createLine(false)
local leftLine, leftGrad, leftOutline = createLine(true)
local rightLine, rightGrad, rightOutline = createLine(true)

local EnableToggle = Subcross:AddToggle("CrosshairEnabled", {Text = "Enable Crosshair", Default = false, Callback = function(val) crosshairEnabled = val end})
local GapSlider = SubcrossP:AddSlider("CrosshairGap", {Text = "Gap", Default = 10, Min = 0, Max = 50, Rounding = 1, Callback = function(val) crosshairGap = val end})
local LengthSlider = SubcrossP:AddSlider("CrosshairLength", {Text = "Length", Default = 20, Min = 1, Max = 50, Rounding = 1, Callback = function(val) crosshairLength = val end})
local WidthSlider = SubcrossP:AddSlider("CrosshairWidth", {Text = "Width", Default = 2, Min = 1, Max = 10, Rounding = 1, Callback = function(val) crosshairWidth = val end})
local SpinToggle = SubcrossP:AddToggle("CrosshairSpin", {Text = "Spin", Default = false, Callback = function(val) crosshairSpin = val end})
local SpinSpeedSlider = SubcrossP:AddSlider("CrosshairSpinSpeed", {Text = "Spin Speed", Default = 1, Min = 0.1, Max = 10, Rounding = 1, Callback = function(val) crosshairSpinSpeed = val end})
local OutlineToggle = SubcrossP:AddToggle("CrosshairOutline", {Text = "Render Outline", Default = true, Callback = function(val) 
    crosshairOutline = val 
    upOutline.Enabled = val
    downOutline.Enabled = val
    leftOutline.Enabled = val
    rightOutline.Enabled = val
end})

local niggasex = SubcrossP:AddLabel("Crosshair Gradient Colors")
local ColorPicker1 = niggasex:AddColorPicker("CrosshairColorFront", {Default = colorStart, Title = "Front Color", Callback = function(val) colorStart = val end})
local ColorPicker2 = niggasex:AddColorPicker("CrosshairColorEnd", {Default = colorEnd, Title = "End Color", Callback = function(val) colorEnd = val end})

local spinAngle = 0
RunService.RenderStepped:Connect(function(dt)
    if not crosshairEnabled then
        Crosshair.Visible = false
        return
    end
    Crosshair.Visible = true

    if crosshairSpin then
        spinAngle = spinAngle + crosshairSpinSpeed * dt * 60
        if spinAngle > 360 then spinAngle = spinAngle - 360 end
    else
        spinAngle = 0
    end
    Crosshair.Rotation = spinAngle

    leftLine.Size = UDim2.new(0,crosshairLength,0,crosshairWidth)
    rightLine.Size = leftLine.Size
    upLine.Size = UDim2.new(0,crosshairWidth,0,crosshairLength)
    downLine.Size = upLine.Size

    leftLine.Position = UDim2.new(0.5, -crosshairGap - crosshairLength/2, 0.5, 0)
    rightLine.Position = UDim2.new(0.5, crosshairGap + crosshairLength/2, 0.5, 0)
    upLine.Position = UDim2.new(0.5, 0, 0.5, -crosshairGap - crosshairLength/2)
    downLine.Position = UDim2.new(0.5, 0, 0.5, crosshairGap + crosshairLength/2)

    upGrad.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,colorStart), ColorSequenceKeypoint.new(1,colorEnd)})
    downGrad.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,colorStart), ColorSequenceKeypoint.new(1,colorEnd)})
    leftGrad.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,colorStart), ColorSequenceKeypoint.new(1,colorEnd)})
    rightGrad.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,colorStart), ColorSequenceKeypoint.new(1,colorEnd)})
end)




boxEspEnabled, nameEspEnabled, hpBarEnabled, hpFlagEnabled = false, false, false, false
visibleFlagEnabled, invisibleFlagEnabled = false, false
itemFlagEnabled = false
rainbowBox,rainbowName,rainbowHP=false,false,false
boxFillEnabled = false
name_size=10
nametagFont=Fonts.Minecraftia
boxTopColor,boxBotColor,nameColor,hpTopColor,hpBotColor=Color3.new(1,1,1),Color3.new(1,1,1),Color3.new(1,1,1),Color3.fromRGB(0,255,0),Color3.fromRGB(255,0,0)
boxFillTopColor, boxFillBotColor = Color3.fromRGB(255,255,255), Color3.fromRGB(0,0,0)
boxFillTopTrans, boxFillBotTrans = 0.5, 0.5
hpFlagPosition="Following"
casingMode="Titlecase"

SubESP:AddToggle("BoxESP",{Text="Box ESP",Default=false,Callback=function(v) boxEspEnabled=v end})
SubESP:AddToggle("BoxFill",{Text="Box Fill",Default=false,Callback=function(v) boxFillEnabled=v end})
SubESP:AddToggle("NameESP",{Text="Nametag ESP",Default=false,Callback=function(v) nameEspEnabled=v end})
SubESP:AddToggle("HPBar",{Text="HP Bar",Default=false,Callback=function(v) hpBarEnabled=v end})
SubESP:AddToggle("HPFlag",{Text="HP Flag",Default=false,Callback=function(v) hpFlagEnabled=v end})
SubESP:AddToggle("VisibleFlag",{Text="Visible Flag",Default=false,Callback=function(v) visibleFlagEnabled=v end})
SubESP:AddToggle("InvisibleFlag",{Text="Hidden Flag",Default=false,Callback=function(v) invisibleFlagEnabled=v end})
SubESP:AddToggle("ItemFlag", {Text="Item Flag", Default=false, Callback=function(v) itemFlagEnabled=v end})
godmodeFlagEnabled = false

SubESP:AddToggle("GodmodeFlag", {
    Text = "Godmode Flag",
    Default = false,
    Callback = function(v)
        godmodeFlagEnabled = v
    end
})

SubESP:AddToggle('DroppedItemESP', {
    Text = 'Dropped Items',
    Tooltip = 'Not recommended.',
    Default = false,
    Callback = function(enabled)
        setfflag("AdornShadingAPI", "true")

        local Workspace = game:GetService("Workspace")
        local CoreGui = game:GetService("CoreGui")

        local function createItemESP(item)
            local container = Instance.new("BillboardGui")
            container.Adornee = item
            container.Size = UDim2.new(0, 100, 0, 50)
            container.AlwaysOnTop = true
            container.Parent = CoreGui

            local name = Instance.new("TextLabel")
            name.AnchorPoint = Vector2.new(0.5,1)
            name.Position = UDim2.new(0.5,0,0,-4)
            name.Size = UDim2.new(1,20,0,14)
            name.BackgroundTransparency = 1
            name.TextScaled = false
            name.TextSize = 14
            name.TextColor3 = GlowColor
            name.FontFace = nametagFont
            name.Text = item.Name
            name.ZIndex = 5
            name.Parent = container

            for _, child in ipairs(item:GetChildren()) do
                if child:IsA("BasePart") or child:IsA("MeshPart") then
                    local adorn = Instance.new("BoxHandleAdornment")
                    adorn.Parent = workspace
                    adorn.Size = child.Size
                    adorn.Adornee = child
                    adorn.AlwaysOnTop = true
                    adorn.Shading = Enum.AdornShading.XRayShaded
                    adorn.Color3 = GlowColor
                    adorn.Transparency = 0
                end
            end
        end

        if not enabled then
            for _, gui in ipairs(CoreGui:GetChildren()) do
                if gui:IsA("BillboardGui") then gui:Destroy() end
            end
            for _, adorn in ipairs(workspace:GetChildren()) do
                if adorn:IsA("BoxHandleAdornment") then adorn:Destroy() end
            end
            return
        end

        for _, item in ipairs(Workspace.DroppedItems:GetChildren()) do
            createItemESP(item)
        end

        Workspace.DroppedItems.ChildAdded:Connect(function(item)
            if enabled then
                createItemESP(item)
            end
        end)
    end
})

SubPersonal:AddSlider("NameSize",{Text="Name Size",Min=6,Max=40,Default=name_size,Rounding=0,Callback=function(v) name_size=v end})
SubPersonal:AddDropdown("NameFont",{Values={"Minecraftia","Tahoma","Heavy"},Default=1,Text="Nametag Font",Callback=function(val) nametagFont=Fonts[val] end})
SubPersonal:AddDropdown("NameCase",{Values={"Lowercase","Uppercase","Titlecase"},Default=3,Text="Nametag Casing",Callback=function(v) casingMode=v end})
SubPersonal:AddToggle("RainbowBox",{Text="Rainbow Box",Default=false,Callback=function(v) rainbowBox=v end})
SubPersonal:AddToggle("RainbowName",{Text="Rainbow Nametag",Default=false,Callback=function(v) rainbowName=v end})
SubPersonal:AddToggle("RainbowHP",{Text="Rainbow HP",Default=false,Callback=function(v) rainbowHP=v end})
local bfl = SubPersonal:AddLabel("Box Fill"):AddColorPicker("BoxFillTop",{Default=boxFillTopColor,Callback=function(c) boxFillTopColor=c end})
SubPersonal:AddSlider("BoxFillTopTrans",{Text="Top Transparency",Min=0,Max=1,Default=boxFillTopTrans,Rounding=2,Callback=function(v) boxFillTopTrans=v end})
bfl:AddColorPicker("BoxFillBot",{Default=boxFillBotColor,Callback=function(c) boxFillBotColor=c end})
SubPersonal:AddSlider("BoxFillBotTrans",{Text="Bottom Transparency",Min=0,Max=1,Default=boxFillBotTrans,Rounding=2,Callback=function(v) boxFillBotTrans=v end})

SubPersonal:AddLabel("Box"):AddColorPicker("BoxTop",{Default=boxTopColor,Callback=function(c) boxTopColor=c end}):AddColorPicker("BoxBot",{Default=boxBotColor,Callback=function(c) boxBotColor=c end})
SubPersonal:AddLabel("Nametag"):AddColorPicker("Nametag",{Default=nameColor,Callback=function(c) nameColor=c end})
SubPersonal:AddLabel("HP"):AddColorPicker("HPTop",{Default=hpTopColor,Callback=function(c) hpTopColor=c end}):AddColorPicker("HPBot",{Default=hpBotColor,Callback=function(c) hpBotColor=c end})
SubPersonal:AddDropdown("HPFlagPos",{Values={"Following","Top Left"},Default=1,Text="HP Flag Pos",Callback=function(v) hpFlagPosition=v end})

ChamData = {}

_G.SHADING_TYPE = Enum.AdornShading.XRay
ChamsEnabled = false
HighlightOn = true
BoxesOn = false
GlowOn = false
FillTrans = 0.5
OutlineTrans = 0
FillColor = Color3.fromRGB(255,255,255)
OutlineColor = Color3.fromRGB(255,255,255)
GlowColor = Color3.fromRGB(255,255,255)
GlowIntensity = 10

Limbs = {"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand",
               "RightUpperArm","RightLowerArm","RightHand","LeftUpperLeg","LeftLowerLeg",
               "LeftFoot","RightUpperLeg","RightLowerLeg","RightFoot"}

function UpdateChamsForAll()
    for plr, data in pairs(ChamData) do
        if data.Highlight then
            data.Highlight.Enabled = ChamsEnabled and HighlightOn
            data.Highlight.FillColor = FillColor
            data.Highlight.OutlineColor = OutlineColor
            data.Highlight.FillTransparency = FillTrans
            data.Highlight.OutlineTransparency = OutlineTrans
        end

        if data.Box then
            for _, box in pairs(data.Box) do
                box.Visible = ChamsEnabled and BoxesOn
                box.Color3 = FillColor
                box.Transparency = FillTrans
            end
        end

        if data.Glow then
            for _, g in pairs(data.Glow) do
                g.Ador.Visible = ChamsEnabled and GlowOn
                local r = math.floor(GlowColor.R*255 * (1 + (GlowIntensity-1)*9/99))
                local g_val = math.floor(GlowColor.G*255 * (1 + (GlowIntensity-1)*9/99))
                local b = math.floor(GlowColor.B*255 * (1 + (GlowIntensity-1)*9/99))
                g.Ador.Color3 = Color3.fromRGB(r, g_val, b)
                g.Ador.ZIndex = -1
                g.Ador.AlwaysOnTop = false
                g.Ador.Shading = _G.SHADING_TYPE
            end
        end
    end
end

local ChamsToggle = SubChams:AddToggle("Chams", {Text="Enable Chams", Default=false, Callback=function(val)
    ChamsEnabled = val
    UpdateChamsForAll()
end})

local HighlightToggle = SubChamsPersonal:AddToggle("HighlightToggle", {Text="Highlight", Default=true, Callback=function(val)
    HighlightOn = val
    UpdateChamsForAll()
end})

local BoxesToggle = SubChamsPersonal:AddToggle("BoxesToggle", {Text="Boxes", Default=false, Callback=function(val)
    BoxesOn = val
    UpdateChamsForAll()
end})

local GlowToggle = SubChamsPersonal:AddToggle("GlowToggle", {Text="Glow", Default=false, Callback=function(val)
    GlowOn = val
    UpdateChamsForAll()
end})

local FillSlider = SubChams:AddSlider("FillTrans", {Text="Fill Transparency", Default=FillTrans, Min=0, Max=1, Rounding=2, Callback=function(val)
    FillTrans = val
    UpdateChamsForAll()
end})

local OutlineSlider = SubChams:AddSlider("OutlineTrans", {Text="Outline Transparency", Default=OutlineTrans, Min=0, Max=1, Rounding=2, Callback=function(val)
    OutlineTrans = val
    UpdateChamsForAll()
end})

local GlowSlider = SubChamsPersonal:AddSlider("GlowIntensity", {Text="Glow Intensity", Default=GlowIntensity, Min=1, Max=10, Rounding=2, Callback=function(val)
    GlowIntensity = val
    UpdateChamsForAll()
end})

local FillColorPicker = SubChamsPersonal:AddLabel("Fill Color"):AddColorPicker("FillColor", {Default=FillColor, Transparency=0, Callback=function(val)
    FillColor = val or Color3.fromRGB(255,255,255)
    UpdateChamsForAll()
end})

local OutlineColorPicker = SubChamsPersonal:AddLabel("Outline Color"):AddColorPicker("OutlineColor", {Default=OutlineColor, Transparency=0, Callback=function(val)
    OutlineColor = val or Color3.fromRGB(255,255,255)
    UpdateChamsForAll()
end})

local GlowColorPicker = SubChamsPersonal:AddLabel("Glow Color"):AddColorPicker("GlowColor", {Default=GlowColor, Transparency=0, Callback=function(val)
    GlowColor = val or Color3.fromRGB(255,255,255)
    UpdateChamsForAll()
end})

local SShadingDropdown = SubChamsPersonal:AddDropdown('ShadingDropdown', {
    Values = {
        '!Occluded',
        'Shaded'
    },
    Default = 1,
    Multi = false,
    Text = 'Glowchams Shading Type',
    Callback = function(val)
        if val == '!Occluded' then
            _G.SHADING_TYPE = Enum.AdornShading.XRay
        elseif val == 'Shaded' then
            _G.SHADING_TYPE = Enum.AdornShading.XRayShaded
        end
    end
})

SShadingDropdown:OnChanged(function()
    local val = SShadingDropdown.Value
    if val == '!Occluded' then
        _G.SHADING_TYPE = Enum.AdornShading.XRay
    elseif val == 'Rounded' then
        _G.SHADING_TYPE = Enum.AdornShading.Rounded
    elseif val == 'Shaded' then
        _G.SHADING_TYPE = Enum.AdornShading.XRayShaded
    end
end)


local combatl = files.gca("combat.png", "images")
Combat = Window:AddTab('Combat', combatl)
local CombatTabbox = Combat:AddLeftTabbox()
local CombatTab = CombatTabbox:AddTab('Targetting')

CombatTab:AddToggle('EnableTargeting', {
    Text = 'Targeting | REQUIRED',
    Default = targeting_flags.enabled,
    Callback = function(v)
        targeting_flags.enabled = v
        fov.Visible = v
    end
})

CombatTab:AddToggle('EnableMI', {
    Text = 'Target MI24V',
    Default = targeting_flags.mitarget,
    Callback = function(v)
        targeting_flags.mitarget = v
    end
})

CombatTab:AddToggle('EnableMI', {
    Text = 'Target Bandits',
    Default = targeting_flags.bandit_target,
    Callback = function(v)
        targeting_flags.bandit_target = v
    end
})

CombatTab:AddToggle('EnableMI', {
    Text = 'Target Bosses',
    Default = targeting_flags.boss_target,
    Callback = function(v)
        targeting_flags.boss_target = v
    end
})

CombatTab:AddSlider('FOVRadius', {
    Text = 'FOV Radius',
    Default = targeting_flags.fov_radius,
    Min = 50,
    Max = 1000,
    Rounding = 1,
    Callback = function(v)
        targeting_flags.fov_radius = v
        fov.Size = UDim2.new(0, v, 0, v)
    end
})

CombatTab:AddSlider('GradientRotation', {
    Text = 'Gradient Rotation',
    Default = targeting_flags.gradient_rot,
    Min = 0,
    Max = 360,
    Rounding = 0,
    Callback = function(v)
        targeting_flags.gradient_rot = v
        gradient.Rotation = v
    end
})

PersonalTab = CombatTabbox:AddTab('Personalisation')

local collb = PersonalTab:AddLabel('Colors')

collb:AddColorPicker('GradientA', {
    Title = 'Gradient Color A',
    Default = targeting_flags.col_a,
    Callback = function(v)
        targeting_flags.col_a = v
        gradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, targeting_flags.col_a),
            ColorSequenceKeypoint.new(1, targeting_flags.col_b)
        }
    end
})

collb:AddColorPicker('GradientB', {
    Title = 'Gradient Color B',
    Default = targeting_flags.col_b,
    Callback = function(v)
        targeting_flags.col_b = v
        gradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, targeting_flags.col_a),
            ColorSequenceKeypoint.new(1, targeting_flags.col_b)
        }
    end
})

PersonalTab:AddToggle('RenderInner', {
    Text = 'Render Inner Stroke',
    Default = targeting_flags.render_inner,
    Callback = function(v)
        targeting_flags.render_inner = v
        stroke_inner.Transparency = v and 0 or 1
    end
})

PersonalTab:AddToggle('RenderMiddle', {
    Text = 'Render Middle Stroke',
    Default = targeting_flags.render_middle,
    Callback = function(v)
        targeting_flags.render_middle = v
        fillStroke.Transparency = v and 0 or 1
    end
})

PersonalTab:AddToggle('RenderOutline', {
    Text = 'Render Outline Stroke',
    Default = targeting_flags.render_outline,
    Callback = function(v)
        targeting_flags.render_outline = v
        outlineStroke.Transparency = v and 0 or 1
    end
})

GunMods = Combat:AddLeftGroupbox("Gunmods")

local env = getgenv()
env.RapidFireDelay = env.RapidFireDelay or 0.01

GunMods:AddSlider("ForceHitDelay", {
    Text = "Forcehit Delay",
    Default = 0.01,
    Min = 0,
    Max = 0.05,
    Rounding = 3,
    Tooltip = "Time in seconds between shots. Lower = faster hits.",
    Callback = function(v)
        env.RapidFireDelay = v
    end
})

GunMods:AddLabel("Forcehit Key"):AddKeyPicker("ForceHitBind", {
    Default = "None",
    SyncToggleState = false,
    Mode = "Hold",
    Text = "Forcehit",
    Tooltip = "RISKY \nHold this key to instantly hit your target, shoots its own bullet and instantly calls inflict."
})

local ForceHitBindObj = Options.ForceHitBind

RS = game:GetService("RunService")
ReplicatedStorage = game:GetService("ReplicatedStorage")

pcallCheck(function()
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local FireProjectile = Remotes:WaitForChild("FireProjectile")
local ProjectileInflict = Remotes:WaitForChild("ProjectileInflict")
end)

local function getTargetPart()
    if not plr_target or plr_target == "" then return nil end

    local plr = Players:FindFirstChild(plr_target)
    if plr and plr.Character then
        return plr.Character:FindFirstChild("Head")
    end

    local cur = workspace
    for seg in string.gmatch(plr_target, "[^/]+") do
        cur = cur and cur:FindFirstChild(seg)
        if not cur then return nil end
    end

    return cur:IsA("BasePart") and cur or nil
end

local function getItemRoot()
    local vm = workspace.Camera:FindFirstChild("ViewModel")
    if not vm then return nil end
    local item = vm:FindFirstChild("Item")
    if not item then return nil end
    return item.PrimaryPart
end

local lastShot = 0

RS.RenderStepped:Connect(function()
    if not ForceHitBindObj:GetState() then return end

    local now = tick()
    if now - lastShot < env.RapidFireDelay then return end
    lastShot = now

    local targetPart = getTargetPart()
    if not targetPart then return end

    local itemRoot = getItemRoot()
    if not itemRoot then return end

    itemRoot.CFrame = CFrame.lookAt(itemRoot.Position, targetPart.Position)
    local shotId = math.random(-10000, 10000)

    FireProjectile:InvokeServer(Vector3.new(0/0,0/0,0/0), shotId, now)

    ProjectileInflict:FireServer(
        targetPart,
        targetPart.CFrame:ToObjectSpace(
            CFrame.new(targetPart.Position + Vector3.new(0,0.01,0))
        ),
        shotId,
        0/0
    )
end)





GunMods:AddToggle("NoRecoilToggle", {
    Text = "No Recoil",
    Default = false,
    Tooltip = "Removes weapon recoil.",
    Callback = function(enabled)
        local char = LocalPlayer.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                if enabled then
                    if hrp:GetAttribute("OriginalRecoil") == nil then
                        hrp:SetAttribute("OriginalRecoil", hrp:GetAttribute("Recoil") or 1)
                    end
                    hrp:SetAttribute("Recoil", 0)
                else
                    local original = hrp:GetAttribute("OriginalRecoil") or 1
                    hrp:SetAttribute("Recoil", original)
                end
            end
        end
    end
})

local RepStorage = game:GetService("ReplicatedStorage")
pcallCheck(function()
local items = RepStorage:WaitForChild("ItemsList")
end)

pcallCheck(function()
local gunModules = {}
local gunSettingsModules = {}
local ammoTypes = RepStorage:WaitForChild("AmmoTypes")
local originals = {}
local originalFireRates = {}
local originalAmmoStats = {}
local cached = false
end)

local function cacheModules()
pcallCheck(function()
	if cached then return end
	table.clear(gunModules)
	table.clear(gunSettingsModules)
	table.clear(originals)
	table.clear(originalFireRates)

	for _, v in ipairs(items:GetDescendants()) do
		if v:IsA("ModuleScript") and v.Name == "SettingsModule" then
			local ok, mod = pcall(require, v)
			if ok and type(mod) == "table" then
				table.insert(gunModules, mod)
				originals[mod] = {
					TouchWallPosY = mod.TouchWallPosY,
					TouchWallPosZ = mod.TouchWallPosZ,
					TouchWallRotX = mod.TouchWallRotX,
					TouchWallRotY = mod.TouchWallRotY,
					AimInSpeed = mod.AimInSpeed,
					AimOutSpeed = mod.AimOutSpeed,
					FireModes = mod.FireModes,
					FireRate = mod.FireRate
				}
				table.insert(gunSettingsModules, mod)
				originalFireRates[mod] = mod.FireRate
			end
		end
	end

	for _, ammo in ipairs(ammoTypes:GetChildren()) do
		originalAmmoStats[ammo] = {
			AccuracyDeviation = ammo:GetAttribute("AccuracyDeviation"),
			ProjectileDrop = ammo:GetAttribute("ProjectileDrop")
		}
	end

	cached = true
    end)
end

cacheModules()

states = {
	noSway = false,
	noObstructions = false,
	instantAim = false,
	unlockFireModes = false,
	rpmBoost = false,
	nospread = false,
	nodrop = false,
	instantEquip = false,
	rpmInterval = 0.05
}

local function applyNoSway()
pcallCheck(function()
	for _, mod in ipairs(gunModules) do
		if states.noSway and mod.updateClient then
			local old_update = mod.updateClient
			mod.updateClient = function(a1,a2,a3)
				local r1,r2,r3 = old_update(a1,a2,a3)
				if states.noSway and a1 and a1.springs then
					for _, spring in pairs(a1.springs) do
						if spring.Position then spring.Position = Vector3.new() end
						if spring.Speed then spring.Speed = 0 end
					end
				end
				return r1,r2,r3
			end
		end
	end
    end)
end

local function applyNoObstructions()
pcallCheck(function()
	if not states.noObstructions then return end
	for _, mod in ipairs(gunModules) do
		pcall(function()
			mod.TouchWallPosY = 0.001
			mod.TouchWallPosZ = 0.001
			mod.TouchWallRotX = 0.001
			mod.TouchWallRotY = 0.001
		end)
	end
    end)
end

local function restoreNoObstructions()
pcallCheck(function()
	for mod, data in pairs(originals) do
		pcall(function()
			mod.TouchWallPosY = data.TouchWallPosY
			mod.TouchWallPosZ = data.TouchWallPosZ
			mod.TouchWallRotX = data.TouchWallRotX
			mod.TouchWallRotY = data.TouchWallRotY
		end)
	end
    end)
end

local function applyInstantAim()
pcallCheck(function()
	for _, mod in ipairs(gunModules) do
		if states.instantAim then
			pcall(function()
				mod.AimInSpeed = 0
				mod.AimOutSpeed = 0
			end)
		end
	end
    end)
end

local function restoreInstantAim()
pcallCheck(function()
	for mod, data in pairs(originals) do
		pcall(function()
			mod.AimInSpeed = data.AimInSpeed
			mod.AimOutSpeed = data.AimOutSpeed
		end)
	end
    end)
end

local function applyUnlockFireModes()
pcallCheck(function()
	if not states.unlockFireModes then return end
	for _, mod in ipairs(gunModules) do
		pcall(function()
			mod.FireModes = { "Auto", "Semi" }
		end)
	end
    end)
end

local function restoreUnlockFireModes()
pcallCheck(function()
	for mod, data in pairs(originals) do
		if data.FireModes then
			pcall(function()
				mod.FireModes = data.FireModes
			end)
		end
	end
    end)
end

local function applyFireRate()
pcallCheck(function()
	if not states.rpmBoost then return end
	for _, mod in ipairs(gunSettingsModules) do
		pcall(function()
			mod.FireRate = states.rpmInterval
		end)
	end
    end)
end

local function restoreFireRate()
pcallCheck(function()
	for mod, rate in pairs(originalFireRates) do
		pcall(function()
			mod.FireRate = rate
		end)
	end
    end)
end

local function applyAmmoMods()
pcallCheck(function()
	for _, ammo in ipairs(ammoTypes:GetChildren()) do
		local stats = originalAmmoStats[ammo]
		if stats then
			if states.nospread then ammo:SetAttribute("AccuracyDeviation", 0) else ammo:SetAttribute("AccuracyDeviation", stats.AccuracyDeviation) end
			if states.nodrop then ammo:SetAttribute("ProjectileDrop", 0) else ammo:SetAttribute("ProjectileDrop", stats.ProjectileDrop) end
		end
	end
    end)
end


GunMods:AddToggle("no_sway", { Text = "No Sway", Default = false, Callback = function(v) states.noSway = v; applyNoSway() end })
GunMods:AddToggle("no_obstructions", { Text = "No Obstructions", Default = false, Callback = function(v) states.noObstructions = v; if v then applyNoObstructions() else restoreNoObstructions() end end })
GunMods:AddToggle("instant_aim", { Text = "Instant Aim", Default = false, Callback = function(v) states.instantAim = v; if v then applyInstantAim() else restoreInstantAim() end end })
GunMods:AddToggle("unlock_firemodes", { Text = "Unlock Firemodes", Default = false, Callback = function(v) states.unlockFireModes = v; if v then applyUnlockFireModes() else restoreUnlockFireModes() end end })
GunMods:AddToggle("rpm_toggle", { Text = "Override firerate", Default = false, Callback = function(v) states.rpmBoost = v; if v then applyFireRate() else restoreFireRate() end end })
GunMods:AddSlider("rpm_slider", { Text = "Firerate", Default = 0.05, Min = 0, Max = 0.1, Rounding = 3, Callback = function(v) states.rpmInterval = v; if states.rpmBoost then applyFireRate() end end })
GunMods:AddToggle("nospread", { Text = "No Spread", Default = false, Callback = function(v) states.nospread = v; applyAmmoMods() end })
GunMods:AddToggle("nodrop", { Text = "No Drop", Default = false, Callback = function(v) states.nodrop = v; applyAmmoMods() end })
GunMods:AddToggle("InstantEquip", { Text = "Instant Equip", Default = false, Callback = function(v) states.instantEquip = v end })

task.spawn(function()
pcallCheck(function()
	while true do
		task.wait(0.001)
		if Library.Unloaded then break end
		if not states.instantEquip then continue end

		local viewModel = workspace:FindFirstChild("Camera")
		if viewModel then viewModel = viewModel:FindFirstChild("ViewModel") end
		if not viewModel then continue end

		local animator = viewModel:FindFirstChildOfClass("Humanoid"):FindFirstChild("Animator")
		if not animator then continue end

		for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
			local anim = track.Animation
			if anim and anim.Name == "Equip" then
				track:AdjustSpeed(15)
				track.TimePosition = track.Length - 0.01
			end
		end
	end
    end)
end)

pcallCheck(function()
ammoTypes.ChildAdded:Connect(function()
	task.wait()
	applyAmmoMods()
end)
end)

getgenv().silent_aim = {
    enabled = false,
    instant = false,
    tracer = false,
    target_part = nil
}


local worl = files.gca("world.png", "images")
local World = Window:AddTab("World", worl)

ModWorldBox = World:AddLeftGroupbox("Modifications")

local Lighting = game:GetService("Lighting")
pcallCheck(function()
Atmosphere = Lighting.Atmosphere
end)

local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
pcallCheck(function()
local Atmosphere = Lighting:FindFirstChildOfClass("Atmosphere")
end)

pcallCheck(function()
world_state = {
    ambient_enabled = false,
    ambient = Lighting.Ambient,

    outdoor_enabled = false,
    outdoor = Lighting.OutdoorAmbient,

    fog_enabled = false,
    fog_color = Atmosphere.Color,
    fog_density = Atmosphere.Density,
    fog_offset = Atmosphere.Offset,

    brightness_enabled = false,
    brightness = Lighting.Brightness,

    shadows_enabled = false,
    shadow_softness = Lighting.ShadowSoftness,

    cstop_enabled = false,
    cstop = Lighting.ColorShift_Top,

    csbot_enabled = false,
    csbot = Lighting.ColorShift_Bottom,

    clock_enabled = false,
    clock = Lighting.ClockTime
}

Toggles.OverrideAmbient = ModWorldBox:AddToggle('OverrideAmbient', {
    Text = 'Override Ambient',
    Default = false,
    Callback = function(v)
        world_state.ambient_enabled = v
    end
})

ModWorldBox:AddLabel('Ambient Color'):AddColorPicker('AmbientCP', {
    Default = world_state.ambient,
    Callback = function(v)
        world_state.ambient = v
    end
})

Toggles.OverrideOutdoor = ModWorldBox:AddToggle('OverrideOutdoor', {
    Text = 'Override OutdoorAmbient',
    Default = false,
    Callback = function(v)
        world_state.outdoor_enabled = v
    end
})

ModWorldBox:AddLabel('OutdoorAmbient Color'):AddColorPicker('OutdoorCP', {
    Default = world_state.outdoor,
    Callback = function(v)
        world_state.outdoor = v
    end
})

Toggles.OverrideFog = ModWorldBox:AddToggle('OverrideFog', {
    Text = 'Override Fog',
    Default = false,
    Callback = function(v)
        world_state.fog_enabled = v
    end
})

ModWorldBox:AddLabel('Fog Color'):AddColorPicker('FogCP', {
    Default = world_state.fog_color,
    Callback = function(v)
        world_state.fog_color = v
    end
})

ModWorldBox:AddSlider('FogDensity', {
    Text = 'Fog Density',
    Min = 0,
    Max = 1,
    Default = world_state.fog_density,
    Rounding = 5,
    Callback = function(v)
        world_state.fog_density = v
    end
})

ModWorldBox:AddSlider('FogOffset', {
    Text = 'Fog Offset',
    Min = 0,
    Max = 25,
    Default = world_state.fog_offset,
    Callback = function(v)
        world_state.fog_offset = v
    end
})

Toggles.OverrideBrightness = ModWorldBox:AddToggle('OverrideBrightness', {
    Text = 'Override Brightness',
    Default = false,
    Callback = function(v)
        world_state.brightness_enabled = v
    end
})

ModWorldBox:AddSlider('BrightnessSlider', {
    Text = 'Brightness',
    Min = 0,
    Max = 10,
    Default = world_state.brightness,
    Callback = function(v)
        world_state.brightness = v
    end
})

Toggles.OverrideGlobalShadows = ModWorldBox:AddToggle('OverrideGlobalShadows', {
    Text = 'Override GlobalShadows',
    Default = false,
    Callback = function(v)
        world_state.shadows_enabled = v
    end
})

ModWorldBox:AddSlider('ShadowSoftness', {
    Text = 'Shadow Softness',
    Min = 0,
    Max = 1,
    Default = world_state.shadow_softness,
    Callback = function(v)
        world_state.shadow_softness = v
    end
})

Toggles.OverrideColorShiftTop = ModWorldBox:AddToggle('OverrideColorShiftTop', {
    Text = 'Override ColorShift Top',
    Default = false,
    Callback = function(v)
        world_state.cstop_enabled = v
    end
})

ModWorldBox:AddLabel('ColorShift Top'):AddColorPicker('CSTopCP', {
    Default = world_state.cstop,
    Callback = function(v)
        world_state.cstop = v
    end
})

Toggles.OverrideColorShiftBottom = ModWorldBox:AddToggle('OverrideColorShiftBottom', {
    Text = 'Override ColorShift Bottom',
    Default = false,
    Callback = function(v)
        world_state.csbot_enabled = v
    end
})

ModWorldBox:AddLabel('ColorShift Bottom'):AddColorPicker('CSBotCP', {
    Default = world_state.csbot,
    Callback = function(v)
        world_state.csbot = v
    end
})

Toggles.OverrideClockTime = ModWorldBox:AddToggle('OverrideClockTime', {
    Text = 'Override ClockTime',
    Default = false,
    Callback = function(v)
        world_state.clock_enabled = v
    end
})

ModWorldBox:AddSlider('ClockTime', {
    Text = 'Clock Time',
    Min = 0,
    Max = 24,
    Default = world_state.clock,
    Callback = function(v)
        world_state.clock = v
    end
})

RunService.RenderStepped:Connect(function()
    if world_state.ambient_enabled then
        Lighting.Ambient = world_state.ambient
    end

    if world_state.outdoor_enabled then
        Lighting.OutdoorAmbient = world_state.outdoor
    end

    if world_state.fog_enabled and Atmosphere then
        Atmosphere.Color = world_state.fog_color
        Atmosphere.Density = world_state.fog_density
        Atmosphere.Offset = world_state.fog_offset
    end

    if world_state.brightness_enabled then
        Lighting.Brightness = world_state.brightness
    end

    if world_state.shadows_enabled then
        Lighting.GlobalShadows = true
        Lighting.ShadowSoftness = world_state.shadow_softness
    end

    if world_state.cstop_enabled then
        Lighting.ColorShift_Top = world_state.cstop
    end

    if world_state.csbot_enabled then
        Lighting.ColorShift_Bottom = world_state.csbot
    end

    if world_state.clock_enabled then
        Lighting.ClockTime = world_state.clock
    end
end)
end)


VisWorldBox = World:AddRightGroupbox("Visibility")

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local mt = getrawmetatable(game)
setreadonly(mt, false)

local oldIndex = mt.__newindex
local oldNamecall = mt.__namecall

local function enableClockLock()
    mt.__newindex = function(t, k, v)
        if t == Lighting and k == "ClockTime" then
            oldIndex(t, k, 24)
        else
            oldIndex(t, k, v)
        end
    end

    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        if self == Lighting and method == "ClockTime" then
            return 24
        end
        return oldNamecall(self, ...)
    end)

    Lighting.ClockTime = 24

    RunService.RenderStepped:Connect(function()
        if Lighting.ClockTime ~= 24 then
            Lighting.ClockTime = 24
        end
    end)
end

local function disableClockLock()
    mt.__newindex = oldIndex
    mt.__namecall = oldNamecall
end

VisWorldBox:AddToggle('ClockLockToggle', {
    Text = 'namecall clocktime',
    Tooltip = "for annoying games, sets to night.",
    Default = false,
    Callback = function(val)
        if val then
            enableClockLock()
        else
            disableClockLock()
        end
    end
})


local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local originalAmbient = Lighting.Ambient
local originalOutdoor = Lighting.OutdoorAmbient
local white = Color3.new(1,1,1)

local fbt = VisWorldBox:AddToggle('FullWhiteLighting', {
    Text = 'Fullbright',
    Tooltip = "!\nUNOPTIMIZED\n\nMakes ambient fully white so you can see.",
    Default = false,
    Callback = function(Value)
        if not Value then
            Lighting.Ambient = originalAmbient
            Lighting.OutdoorAmbient = originalOutdoor
        end
    end
})

RunService.RenderStepped:Connect(function()
    if fbt.Value then
        if Lighting.Ambient ~= white then
            Lighting.Ambient = white
        end
        if Lighting.OutdoorAmbient ~= white then
            Lighting.OutdoorAmbient = white
        end
    end
end)


pcallCheck(function()
local FoliageSurfacePartsToggle = VisWorldBox:AddToggle('FoliageSurfaceParts', {
    Text = 'No Foliage',
    Default = false,
    Tooltip = 'Removes shit so u can see',

    Callback = function(Value)
        local Foliage = workspace:WaitForChild("SpawnerZones"):WaitForChild("Foliage")
        local Stored = getgenv()._StoredFoliage or {}
        getgenv()._StoredFoliage = Stored

        local function hasSurfaceAppearance(part)
            for _, desc in ipairs(part:GetDescendants()) do
                if desc:IsA("SurfaceAppearance") then
                    return true
                end
            end
            return false
        end

        if Value then
            table.clear(Stored)
            for _, v in ipairs(Foliage:GetDescendants()) do
                if v:IsA("BasePart") and hasSurfaceAppearance(v) then
                    Stored[#Stored+1] = {v, v.Parent}
                    v.Parent = nil
                end
            end
        else
            for _, data in ipairs(Stored) do
                local part, parent = data[1], data[2]
                if part and parent then
                    part.Parent = parent
                end
            end
            table.clear(Stored)
        end
    end
})
end)

AimLockBox = Combat:AddRightGroupbox("Aimlock")

local AimLockToggle = AimLockBox:AddToggle("AimlockEnabled", {
    Text = "Enable Aimlock",
    Default = false
})

AimLockToggle:AddKeyPicker("AimlockKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Hold",
    Text = "Aimlock"
})

local AimLockSmooth = AimLockBox:AddSlider("AimlockSmooth", {
    Text = "Accuracy",
    Default = 1,
    Min = 0,
    Max = 1,
    Rounding = 2
})

task.spawn(function()
    while task.wait() do
        if not Toggles.AimlockEnabled.Value then continue end
        local keyObj = Options.AimlockKey
        if not keyObj.Value then continue end
        local targetInstance

        if typeof(plr_target) == "string" then
            local plr = Players:FindFirstChild(plr_target)
            if plr and plr.Character then
                targetInstance = plr.Character:FindFirstChild("Head") or plr.Character:FindFirstChild("HumanoidRootPart")
            else
                pcall(function()
                    local path = plr_target:split("/")
                    local obj = workspace
                    for _, v in ipairs(path) do
                        obj = obj and obj:FindFirstChild(v)
                    end
                    targetInstance = obj
                end)
            end
        elseif typeof(plr_target) == "Instance" then
            targetInstance = plr_target:FindFirstChild("HumanoidRootPart") or plr_target:FindFirstChild("Head") or plr_target
        end

        if targetInstance then
            local cam = workspace.CurrentCamera
            cam.CFrame = cam.CFrame:Lerp(CFrame.new(cam.CFrame.Position, targetInstance.Position), Options.AimlockSmooth.Value)
        end
    end
end)
LeftGroupBox = Combat:AddRightGroupbox("Silent Aim")

pcallCheck(function()
LeftGroupBox:AddToggle("SilentAimEnabled", {
    Text = "Silent Aim",
    Default = false,
    Tooltip = "Xeno/Solara do not support this function. | Toggle silent aim on/off",
    Callback = function(value)
        silent_aim.enabled = value
    end
})

LeftGroupBox:AddToggle("InstantHit", {
    Text = "Instant Hit",
    Default = false,
    Tooltip = "Xeno/Solara do not support this function. | Bullets hit instantly",
    Callback = function(value)
        silent_aim.instant = value
    end
})

local hitmarkerColor = Color3.fromRGB(255, 255, 255)

local TracerGroup = Combat:AddRightGroupbox("FX")

local ws = workspace
local RunService = game:GetService("RunService")
local Camera = ws:WaitForChild("Camera")

local EnableTracers = TracerGroup:AddToggle("EnableTracers", {
    Text = "Bullet Tracers",
    Default = false,
    Tooltip = "Toggle bullet tracers on/off",
})

local TracerColorStart = EnableTracers:AddColorPicker("TracerColorStart", {
    Default = Color3.fromRGB(255, 80, 80),
    Title = "Start Color",
})

local TracerColorEnd = EnableTracers:AddColorPicker("TracerColorEnd", {
    Default = Color3.fromRGB(255, 255, 80),
    Title = "End Color",
})

local textures = {
    Neon = "rbxassetid://90961491521758",
    Lightning = "rbxassetid://247707396",
    ["Tiny Lightning"] = "rbxassetid://7151778302",
    Wave = "rbxassetid://123453630521207",
    Beam = "rbxassetid://6376702661",
}

local TracerTexture = TracerGroup:AddDropdown("TracerTexture", {
    Values = {"Neon","Lightning","Tiny Lightning","Wave","Beam"},
    Default = "Neon",
    Multi = false,
    Text = "Tracer Texture",
    Tooltip = "Select your tracer texture",
})

local TracerWidth = TracerGroup:AddSlider("TracerWidth", {Text = "Tracer Width", Default = 0.08, Min = 0.01, Max = 1, Rounding = 2})
local TracerLifetime = TracerGroup:AddSlider("TracerLifetime", {Text = "Tracer Lifetime", Default = 0.25, Min = 0.05, Max = 2, Rounding = 2})
local TracerFade = TracerGroup:AddSlider("TracerFade", {Text = "Tracer Fadeout", Default = 0.25, Min = 0.05, Max = 2, Rounding = 2})

local rayParams = RaycastParams.new()
rayParams.FilterType = Enum.RaycastFilterType.Exclude
rayParams.IgnoreWater = true
rayParams.FilterDescendantsInstances = {ws:FindFirstChild("NoCollision"), Camera}

local function createBeam(origin, target)
    if not EnableTracers.Value then return end

    local startColor = TracerColorStart.Value
    if typeof(startColor) ~= "Color3" then
        startColor = Color3.fromRGB(255, 80, 80)
    end

    local endColor = TracerColorEnd.Value
    if typeof(endColor) ~= "Color3" then
        endColor = startColor
    end

    local texture = textures[TracerTexture.Value] or textures.Neon
    local width = TracerWidth.Value
    local lifetime = TracerLifetime.Value
    local fadeout = TracerFade.Value

    local p1 = Instance.new("Part", ws)
    local p2 = Instance.new("Part", ws)
    p1.Position = origin
    p2.Position = target
    p1.Anchored = true
    p2.Anchored = true
    p1.CanCollide = false
    p2.CanCollide = false
    p1.Size = Vector3.zero
    p2.Size = Vector3.zero
    p1.Transparency = 1
    p2.Transparency = 1

    local a1 = Instance.new("Attachment", p1)
    local a2 = Instance.new("Attachment", p2)

    local beam = Instance.new("Beam", ws)
    beam.Attachment0 = a1
    beam.Attachment1 = a2

    beam.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, startColor),
        ColorSequenceKeypoint.new(1, endColor)
    })

    beam.LightEmission = 1
    beam.LightInfluence = 1
    beam.TextureMode = Enum.TextureMode.Static
    beam.Texture = texture
    beam.FaceCamera = true
    beam.Width0 = width
    beam.Width1 = width
    beam.Segments = 1
    beam.Transparency = NumberSequence.new(0)

    local startTime = tick()
    local conn
    conn = RunService.RenderStepped:Connect(function()
        local elapsed = tick() - startTime
        local alpha = math.clamp(elapsed / fadeout, 0, 1)
        beam.Transparency = NumberSequence.new(alpha)
        if elapsed >= lifetime then
            conn:Disconnect()
            p1:Destroy()
            p2:Destroy()
            beam:Destroy()
        end
    end)
end

local function watchItem(item)
    if not item then return end
    local barrel = item:FindFirstChild("Barrel")
    if not barrel then return end

    barrel.ChildAdded:Connect(function(child)
        if child.Name:lower() == "smoke" then
            local origin = barrel.Position
            local direction = barrel.CFrame.LookVector * 1000
            local result = ws:Raycast(origin, direction, rayParams)
            local hitPos = result and result.Position or (origin + direction)
            createBeam(origin, hitPos)
        end
    end)
end

local function watchViewModel(vm)
    if not vm then return end
    local function attachItem(item) watchItem(item) end

    local item = vm:FindFirstChild("Item")
    if item then attachItem(item) end

    vm.ChildAdded:Connect(function(child)
        if child.Name:lower() == "item" then attachItem(child) end
    end)
end

if Camera:FindFirstChild("ViewModel") then
    watchViewModel(Camera.ViewModel)
end

Camera.ChildAdded:Connect(function(child)
    if child.Name:lower() == "viewmodel" then
        watchViewModel(child)
    end
end)

end)

local playerl = files.gca("player.png", "images")
Plr = Window:AddTab('Player', playerl)

end)
registerFuncAuto(function()

AntiAimTab = Plr:AddLeftGroupbox('Antiaim')
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HRP = Character:WaitForChild("HumanoidRootPart")
local Camera = workspace.CurrentCamera

spoofing = false
local offsetX, offsetY, offsetZ = 0, 0, 0
local rotX, rotY, rotZ = 0, 0, 0

local Toggle = AntiAimTab:AddToggle("HRPSpoof", {
    Text = "Spoofer",
    Tooltip = "Changes your position without replicating to your client.",
    Default = false
})

AntiAimTab:AddSlider("SpoofX", {
    Text = "X Offset",
    Min = -10,
    Max = 10,
    Default = 0,
    Rounding = 2,
    Callback = function(v) offsetX = v end
})

if UNIVERSAL then
    AntiAimTab:AddSlider("SpoofY", {
        Text = "Y Offset",
        Min = -60,
        Max = 150,
        Default = 0,
        Rounding = 2,
        Callback = function(v) offsetY = v end
    })
else
    AntiAimTab:AddSlider("SpoofY", {
        Text = "Y Offset",
        Min = -4,
        Max = 7,
        Default = 0,
        Rounding = 2,
        Callback = function(v) offsetY = v end
    })
end

AntiAimTab:AddSlider("SpoofZ", {
    Text = "Z Offset",
    Min = -10,
    Max = 10,
    Default = 0,
    Rounding = 2,
    Callback = function(v) offsetZ = v end
})

AntiAimTab:AddSlider("SpoofRotX", {
    Text = "X Rot (deg)",
    Min = -180,
    Max = 180,
    Default = 0,
    Rounding = 1,
    Callback = function(v) rotX = math.rad(v) end
})

AntiAimTab:AddSlider("SpoofRotY", {
    Text = "Y Rot (deg)",
    Min = -180,
    Max = 180,
    Default = 0,
    Rounding = 1,
    Callback = function(v) rotY = math.rad(v) end
})

AntiAimTab:AddSlider("SpoofRotZ", {
    Text = "Z Rot (deg)",
    Min = -180,
    Max = 180,
    Default = 0,
    Rounding = 1,
    Callback = function(v) rotZ = math.rad(v) end
})

Toggle:AddKeyPicker("HRPSpoofKey", {
    Default = "None",
    Text = "Spoofer",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function()
        spoofing = Toggle.Value
    end
})
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local HRP

RunService.Heartbeat:Connect(function()
    if spoofing or not HRP then return end

    local oldCFrame = HRP.CFrame

    local posCf = CFrame.new(offsetX, offsetY, offsetZ)
    local rotCf = CFrame.Angles(rotX, rotY, rotZ)
    local spoofCf = posCf * rotCf

    HRP.CFrame = oldCFrame * spoofCf

    RunService.RenderStepped:Wait()

    if HRP then
        HRP.CFrame = oldCFrame
        local camPos = Camera.CFrame.Position - posCf.Position
        Camera.CFrame = CFrame.new(camPos, camPos + Camera.CFrame.LookVector)
    end
end)

local function onChar(char)
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    onChar(LocalPlayer.Character)
end

if UNIVERSAL then
    LocalPlayer.CharacterAdded:Connect(onChar)
end


local shotResolverEnabled = false
local oldSpoofingState = false

local ShotResolverToggle = AntiAimTab:AddToggle("ShotResolver", {
    Text = "Shot Resolver",
    Tooltip = "Shooting means you will be send out of spoofing extremely briefly for just enough to hit people. This is useful in games with strict hitreg.",
    Default = false,
    Callback = function(v)
        shotResolverEnabled = v
    end
})

local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if not shotResolverEnabled then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        oldSpoofingState = spoofing
        spoofing = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if not shotResolverEnabled then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        spoofing = oldSpoofingState
    end
end)

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local UPAngleChanger = false
local RandomYawActive = false
local ZeroTiltActive = false
local UPAngleValue = 0

AntiAimTab:AddToggle('YawChanger', {
    Text = 'Player Yaw Editor',
    Default = false,
    Callback = function(val)
        UPAngleChanger = val
        if UPAngleChanger and ZeroTiltActive then
            Library:Notify("You cannot use NaN UpAngle and a spoofed UpAngle", 5)
        end
    end
})

AntiAimTab:AddSlider('YawValue', {
    Text = 'Player Yaw',
    Tooltip = 'Sets your characters rotation. -160 = looking down, 160 = looking up',
    Default = 0,
    Min = -160,
    Max = 160,
    Rounding = 1,
    Callback = function(val)
        UPAngleValue = val
    end
})

AntiAimTab:AddToggle('RandomYaw', {
    Text = 'Randomise Yaw',
    Default = false,
    Callback = function(val)
        RandomYawActive = val
    end
})

AntiAimTab:AddToggle('ZeroTilt', {
    Text = 'Amogus',
    Tooltip = 'Cannot be used with Player Yaw | removes your head and puts your arms inside of your body, making you very hard to hit. does make you look likee a fucking chicken nugget tho',
    Default = false,
    Callback = function(val)
        ZeroTiltActive = val
        if UPAngleChanger and ZeroTiltActive then
            Library:Notify("You cannot use NaN UpAngle and a spoofed UpAngle", 5)
        end
    end
})

if UNIVERSAL then
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local RunService = game:GetService("RunService")

    local sliderObj = AntiAimTab:AddSlider("noclip_push_distance", {
        Text = "Push Distance",
        Default = 3,
        Min = 0.1,
        Max = 10,
        Rounding = 1
    })

    AntiAimTab:AddButton({
        Text = "Noclip Push",
        Func = function()
            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local distance = sliderObj.Value
            local startCFrame = hrp.CFrame
            local targetCFrame = startCFrame + startCFrame.LookVector * distance
            local duration = 0.1
            local elapsed = 0

            local conn
            conn = RunService.RenderStepped:Connect(function(dt)
                elapsed = elapsed + dt
                local alpha = math.clamp(elapsed / duration, 0, 1)
                hrp.CFrame = startCFrame:Lerp(targetCFrame, alpha)
                if alpha >= 1 then
                    conn:Disconnect()
                end
            end)
        end,
        DoubleClick = false,
        Tooltip = "DETECTED\n\nPushes you {Slider amount} forwards through walls.",
    })
end

RunService.RenderStepped:Connect(function()
    if Library.Unloaded then return end
    local char = game.Players.LocalPlayer.Character
    if not char then return end

    local success, remote = pcall(function()
        return ReplicatedStorage.Remotes.UpdateTilt
    end)
    if not (success and remote) then return end

    if UPAngleChanger and ZeroTiltActive then
        return
    end

    if UPAngleChanger then
        if RandomYawActive then
            if UPAngleValue == 160 then
                UPAngleValue = -160
            else
                UPAngleValue = 160
            end
        end
        remote:FireServer(UPAngleValue or 0)
        return
    end

    if ZeroTiltActive then
        remote:FireServer(0/0)
        return
    end
end)





SpeedTab = Plr:AddLeftGroupbox("Movement")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local flying = false
local flySpeed = 40
local keys = { w=false, a=false, s=false, d=false, up=false, down=false }

local function setupCharacter(c)
    hrp = c:WaitForChild("HumanoidRootPart")
    flying = false
    for k,v in pairs(keys) do keys[k] = false end
end

plr.CharacterAdded:Connect(setupCharacter)

local flyt = SpeedTab:AddToggle("FlyToggle", {
    Text = "Flyhack",
    Default = false,
    Callback = function(val)
        flying = val
        if not flying then hrp.Velocity = Vector3.zero end
    end 
})

flyt:AddKeyPicker("FlyKeybind", {
    Default = "None",
    Mode = "Toggle",
    Text = "Flyhack",
    Callback = function(val)
        flying = val
        if not flying then hrp.Velocity = Vector3.zero end
    end
})

SpeedTab:AddSlider("FlySpeed", {
    Text = "Fly Speed",
    Default = 40,
    Min = 5,
    Max = 200,
    Rounding = 1,
    Callback = function(val)
        flySpeed = val
    end
})

UIS.InputBegan:Connect(function(input,gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.W then keys.w = true end
    if input.KeyCode == Enum.KeyCode.A then keys.a = true end
    if input.KeyCode == Enum.KeyCode.S then keys.s = true end
    if input.KeyCode == Enum.KeyCode.D then keys.d = true end
    if input.KeyCode == Enum.KeyCode.Space then keys.up = true end
    if input.KeyCode == Enum.KeyCode.LeftControl then keys.down = true end
end)

UIS.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.W then keys.w = false end
    if input.KeyCode == Enum.KeyCode.A then keys.a = false end
    if input.KeyCode == Enum.KeyCode.S then keys.s = false end
    if input.KeyCode == Enum.KeyCode.D then keys.d = false end
    if input.KeyCode == Enum.KeyCode.Space then keys.up = false end
    if input.KeyCode == Enum.KeyCode.LeftControl then keys.down = false end
end)

RunService.RenderStepped:Connect(function()
    if not flying or not hrp then return end

    local cam = workspace.CurrentCamera
    local move = Vector3.zero
    if keys.w then move += cam.CFrame.LookVector end
    if keys.s then move -= cam.CFrame.LookVector end
    if keys.a then move -= cam.CFrame.RightVector end
    if keys.d then move += cam.CFrame.RightVector end
    if keys.up then move += Vector3.new(0,1,0) end
    if keys.down then move -= Vector3.new(0,1,0) end

    hrp.Velocity = move.Magnitude > 0 and move.Unit * flySpeed or Vector3.zero
end)

hvhTab = Plr:AddRightGroupbox("HVH")

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local player = Players.LocalPlayer

local character, hrp

local function bindCharacter(char)
    character = char
    hrp = char:WaitForChild("HumanoidRootPart")
end

bindCharacter(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(bindCharacter)

getgenv().UR_Enabled = false
getgenv().UR_Amount = 10
getgenv().UR_FireType = "On Press"

local function pulse()
    if not getgenv().UR_Enabled or not hrp then return end
    hrp.CFrame = hrp.CFrame * CFrame.new(0, -getgenv().UR_Amount, 0)
end

UIS.InputBegan:Connect(function(input, gp)
    if gp then return end
    if getgenv().UR_Enabled and getgenv().UR_FireType == "On Press" and input.UserInputType == Enum.UserInputType.MouseButton1 then
        pulse()
    end
end)

pcallCheck(function()
pcall(function()
    local mt = getrawmetatable(game)
    local old = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(self, ...)
        local success, method = pcall(getnamecallmethod)
        if success and method == "InvokeServer" and self.Name == "FireProjectile" then
            if getgenv().UR_Enabled and getgenv().UR_FireType == "On Remote" then
                pulse()
            end
        end
        return old(self, ...)
    end)
    setreadonly(mt, true)
end)
end)

local URToggle = hvhTab:AddToggle("UR_Toggle", {Text = "Underground Resolver", Default = false})
URToggle:AddKeyPicker("UR_Key", {Text = "Resolver [UG]",Default = "None", SyncToggleState = true})
local URType = hvhTab:AddDropdown("UR_Type", {Text = "Fire Type", Values = {"On Press", "On Remote"}, Default = 1})
local URAmount = hvhTab:AddSlider("UR_Amount", {Text = "Depth (Studs)", Min = 1, Max = 50, Default = 10, Rounding = 1})

URToggle:OnChanged(function()
    getgenv().UR_Enabled = Toggles.UR_Toggle.Value
end)

Options.UR_Type:OnChanged(function()
    getgenv().UR_FireType = Options.UR_Type.Value
end)

Options.UR_Amount:OnChanged(function()
    getgenv().UR_Amount = Options.UR_Amount.Value
end)

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local player = Players.LocalPlayer

local character, hrp

local function bindCharacter(char)
    character = char
    hrp = char:WaitForChild("HumanoidRootPart")
end

bindCharacter(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(bindCharacter)

getgenv().SP_Enabled = false
getgenv().SP_Amount = 10
getgenv().SP_FireType = "On Press"

local function pulse()
    if not getgenv().SP_Enabled or not hrp then return end
    hrp.CFrame = hrp.CFrame * CFrame.new(0, getgenv().SP_Amount, 0)
end

UIS.InputBegan:Connect(function(input, gp)
    if gp then return end
    if getgenv().SP_Enabled and getgenv().SP_FireType == "On Press" and input.UserInputType == Enum.UserInputType.MouseButton1 then
        pulse()
    end
end)
pcallCheck(function()
pcall(function()
    local mt = getrawmetatable(game)
    local old = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(self, ...)
        local success, method = pcall(getnamecallmethod)
        if success and method == "InvokeServer" and self.Name == "FireProjectile" then
            if getgenv().SP_Enabled and getgenv().SP_FireType == "On Remote" then
                pulse()
            end
        end
        return old(self, ...)
    end)
    setreadonly(mt, true)
end)
end)
local SPToggle = hvhTab:AddToggle("SP_Toggle", {Text = "Sky Peek", Default = false})
SPToggle:AddKeyPicker("SP_Key", {Text = "Sky Peek", Default = "None", SyncToggleState = true})
local SPType = hvhTab:AddDropdown("SP_Type", {Text = "Fire Type", Values = {"On Press", "On Remote"}, Default = 1})
local SPAmount = hvhTab:AddSlider("SP_Amount", {Text = "Height (Studs)", Min = 1, Max = 50, Default = 10, Rounding = 1})

SPToggle:OnChanged(function()
    getgenv().SP_Enabled = Toggles.SP_Toggle.Value
end)

Options.SP_Type:OnChanged(function()
    getgenv().SP_FireType = Options.SP_Type.Value
end)

Options.SP_Amount:OnChanged(function()
    getgenv().SP_Amount = Options.SP_Amount.Value
end)

BypassTab = Plr:AddRightGroupbox("Bypass")

speedState = {
    enabled = false,
    key = "None",
    speed = 1,
    type = "Walkspeed"
}
local toggleObj = SpeedTab:AddToggle("speed_toggle", { Text = "Speedhack", Default = false })
local keypickerLabel = toggleObj:AddKeyPicker("speed_keypicker", { Text = "Speedhack", Default = "None", Mode = "Toggle" })
local sliderObj = SpeedTab:AddSlider("speed_value", { Text = "Speed Value", Default = 1, Min = 0, Max = 1.5, Rounding = 2 })
dropdownObj = SpeedTab:AddDropdown("speed_type", { Text = "Speedhack Type", Values = { "Walkspeed", "CFrame", "TranslateBy" }, Default = 1 })

end)
registerFuncAuto(function()

BypassTab:AddToggle('NoFallToggle', {
    Text = 'Bypass Fall',
    Default = false,
    Tooltip = 'prevent fall damage '
})
task.wait()

keyObj = Options.speed_keypicker
toggleFlag = Toggles.speed_toggle
sliderFlag = Options.speed_value
dropdownFlag = Options.speed_type

toggleFlag:OnChanged(function(v) speedState.enabled = v end)
keyObj:OnChanged(function(k) speedState.key = k end)
sliderFlag:OnChanged(function(v) speedState.speed = v end)
dropdownFlag:OnChanged(function(v) speedState.type = v end)

end)
registerFuncAuto(function()


CamTab = Plr:AddRightGroupbox('Camera')
if games.town then
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local plr = Players.LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local viewmodelEnabled = false
    local offset = Vector3.new(0.6, 0.15, 0)

    CamTab:AddToggle("ViewmodelToggle", {
        Text = "Viewmodel Editor",
        Default = false,
        Callback = function(val)
            viewmodelEnabled = val
        end
    })
local function createSlider(name, axis)
    local default
    if axis == 1 then default = offset.X
    elseif axis == 2 then default = offset.Y
    elseif axis == 3 then default = offset.Z
    end

    return CamTab:AddSlider(name, {
        Text = "Offset "..axis,
        Default = default,
        Min = -2,
        Max = 2,
        Rounding = 2,
        Callback = function(val)
            offset = Vector3.new(
                axis == 1 and val or offset.X,
                axis == 2 and val or offset.Y,
                axis == 3 and val or offset.Z
            )
        end
    })
end



    createSlider("OffsetX", 1)
    createSlider("OffsetY", 2)
    createSlider("OffsetZ", 3)

    local tools = {}

    local function trackTool(tool)
        if tool and tool:IsA("Tool") and tool:FindFirstChild("ViewModelOffset") then
            tools[tool] = tool.ViewModelOffset
            if viewmodelEnabled then
                tool.ViewModelOffset.Value = offset
            end
        end
    end

    local function untrackTool(tool)
        tools[tool] = nil
    end

    local function setupCharacter(c)
        char = c
        tools = {}

        for _, child in ipairs(char:GetChildren()) do
            trackTool(child)
        end

        char.ChildAdded:Connect(trackTool)
        char.ChildRemoved:Connect(untrackTool)
    end

    setupCharacter(char)

    plr.CharacterAdded:Connect(function(c)
        wait(0.1)
        setupCharacter(c)
    end)

    RunService.RenderStepped:Connect(function()
        if not viewmodelEnabled then return end
        for _, vm in pairs(tools) do
            if vm then
                vm.Value = offset
            end
        end
    end)
end

pcallCheck(function()
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local UserInputService = game:GetService("UserInputService")
local lp = Players.LocalPlayer

local activeRemovals = {}
local originalBlurSize = nil
local blurHookConnected = false

local function getGui()
	return lp:FindFirstChild("PlayerGui")
end

local function backgroundFrames(pg)
	local backpackFrame = pg
		:FindFirstChild("MainGui", true)
		:FindFirstChild("MainFrame", true)
		:FindFirstChild("BackpackFrame", true)

	if not backpackFrame then return end

	local targets = {
		"CharacterFrame",
		"InventoryFrame",
		"Loot"
	}

	for i = 1, #targets do
		local f = backpackFrame:FindFirstChild(targets[i], true)
		if f and f:IsA("Frame") then
			f.BackgroundTransparency = 1
		end
	end

	for _, obj in ipairs(backpackFrame:GetDescendants()) do
		if obj:IsA("ImageLabel") and obj.Name == "Decor" then
			obj.ImageTransparency = 1
		end
	end
end

local function disableEffect(pg, name)
	local effect = pg
		:FindFirstChild("NoInsetGui", true)
		:FindFirstChild("MainFrame", true)
		:FindFirstChild("ScreenEffects", true)
		:FindFirstChild(name, true)

	if effect then
		effect.Visible = false
	end
end

local function toggleInventoryBlur(enabled)
	local blur = Lighting:FindFirstChild("InventoryBlur")
	if not blur or not blur:IsA("BlurEffect") then return end

	if enabled then
		if originalBlurSize == nil then
			originalBlurSize = blur.Size
		end
		if not blurHookConnected then
			blurHookConnected = true
			UserInputService.InputBegan:Connect(function(input, gpe)
				if gpe then return end
				if input.KeyCode == Enum.KeyCode.Tab then
					blur.Size = 0
				end
			end)
		end
	else
		if originalBlurSize then
			blur.Size = originalBlurSize
			originalBlurSize = nil
		end
		blurHookConnected = false
	end
end

local handlers = {
	BackgroundFrames = function(pg)
		backgroundFrames(pg)
	end,
	Visor = function(pg)
		disableEffect(pg, "Visor")
	end,
	Flashbang = function(pg)
		disableEffect(pg, "Flashbang")
	end,
	Mask = function(pg)
		disableEffect(pg, "Mask")
	end,
	Scopes = function(pg)
		disableEffect(pg, "Scopes")
	end,
	InventoryBlur = function(pg)
		toggleInventoryBlur(true)
	end,
}

local function applyAll()
	local pg = getGui()
	if not pg then return end

	for k in pairs(activeRemovals) do
		local fn = handlers[k]
		if fn then
			fn(pg)
		end
	end

	if not activeRemovals.InventoryBlur then
		toggleInventoryBlur(false)
	end
end

lp.CharacterAdded:Connect(function()
	task.wait(0.5)
	applyAll()
end)

local RemovalDropdownM = CamTab:AddDropdown("RemovalDropdown", {
	Values = {
		"BackgroundFrames",
		"Visor",
		"Flashbang",
		"Mask",
		"Scopes",
		"InventoryBlur",
	},
	Multi = true,
	Text = "Removals",
})

RemovalDropdownM:OnChanged(function()
	table.clear(activeRemovals)
	for name, enabled in pairs(Options.RemovalDropdown.Value) do
		if enabled then
			activeRemovals[name] = true
		end
	end
	applyAll()
end)
end)
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local lp = Players.LocalPlayer
local char = lp.Character or lp.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")
local cam = workspace.CurrentCamera

local tpEnabled = false
local tpZ = 5
local tpY = 1

local visEnabled = false
local visMaterial = Enum.Material.ForceField
local visTransparency = 0.5
local visGlowEnabled = false
local visGlowIntensity = 25

local boxColor = Color3.fromRGB(255,255,255)

local Limbs = {}
if char:FindFirstChild("Torso") then
    Limbs = {"Head","Torso","Left Arm","Right Arm","Left Leg","Right Leg"}
else
    Limbs = {"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand",
             "RightUpperArm","RightLowerArm","RightHand","LeftUpperLeg","LeftLowerLeg","LeftFoot",
             "RightUpperLeg","RightLowerLeg","RightFoot"}
end

local visuals = {}

local tpt = CamTab:AddToggle("ThirdPersonToggle",{Text="Third Person", Default=false})
tpt:OnChanged(function(v) tpEnabled = v end)
tpt:AddKeyPicker("ThirdPersonBind",{Default="None", Text="Third Person", Mode="Toggle", SyncToggleState=true})

local tpDistSlider = CamTab:AddSlider("ThirdPersonZ",{Text="Distance", Default=tpZ, Min=0, Max=10, Rounding=2})
tpDistSlider:OnChanged(function(v) tpZ = v end)

local tpVSlider = CamTab:AddSlider("ThirdPersonY",{Text="Vertical Offset", Default=tpY, Min=-100, Max=50, Rounding=2})
tpVSlider:OnChanged(function(v) tpY = v end)

local visToggle = CamTab:AddToggle("VisualiserToggle",{Text="Visualiser", Default=false})
visToggle:OnChanged(function(v) visEnabled = v end)

local matDropdown = CamTab:AddDropdown("VisualiserMaterial",{Text="Material", Values={"ForceField","Neon"}, Default=1})
matDropdown:OnChanged(function(v) visMaterial = v=="Neon" and Enum.Material.Neon or Enum.Material.ForceField end)

local transSlider = CamTab:AddSlider("VisualiserTransparency",{Text="Transparency", Min=0, Max=1, Default=visTransparency, Rounding=2})
transSlider:OnChanged(function(v) visTransparency = v end)

local glowToggle = CamTab:AddToggle("VisualiserGlow",{Text="Glow", Default=false})
glowToggle:OnChanged(function(v) visGlowEnabled = v end)

local glowSlider = CamTab:AddSlider("GlowIntensity",{Text="Glow Intensity", Min=1, Max=50, Default=visGlowIntensity, Rounding=0})
glowSlider:OnChanged(function(v) visGlowIntensity = v end)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local plr = Players.LocalPlayer
local root = workspace:FindFirstChild("NoCollision") or workspace
local effects = root:FindFirstChild("Effects")
if not effects then
    effects = Instance.new("Folder")
    effects.Name = "Effects"
    effects.Parent = root
end

local visuals = {}
local model
local cam = workspace.CurrentCamera

local function setupVisuals(char)
    if model then
        model:Destroy()
        visuals = {}
    end

    model = Instance.new("Model")
    model.Name = "TPVisuals"
    model.Parent = effects

    for _, name in ipairs(Limbs) do
        local src = char:FindFirstChild(name)
        if src and src:IsA("BasePart") then
            local p = Instance.new("Part")
            p.Size = src.Size
            p.Anchored = true
            p.CanCollide = false
            p.CanTouch = false
            p.CanQuery = false
            p.Material = visMaterial
            p.Color = boxColor
            p.Transparency = 1
            p.Parent = model

            local ador = Instance.new("BoxHandleAdornment")
            ador.Size = src.Size
            ador.Adornee = src
            ador.ZIndex = 5
            ador.AlwaysOnTop = true
            ador.Visible = false
            ador.Parent = src

            visuals[src] = {Part=p, GlowAdor=ador}
        end
    end
end

local char = plr.Character or plr.CharacterAdded:Wait()
setupVisuals(char)

plr.CharacterAdded:Connect(function(c)
    char = c
    wait(0.1)
    setupVisuals(char)
end)

RunService:BindToRenderStep("ThirdPersonCamera", Enum.RenderPriority.Camera.Value+1, function()
    if tpEnabled then
        cam.CFrame = cam.CFrame * CFrame.new(0,tpY,tpZ)
    end

    local showVisuals = tpEnabled and visEnabled
    for src, data in pairs(visuals) do
        if src and data.Part and data.GlowAdor then
            data.Part.CFrame = src.CFrame
            data.Part.Material = visMaterial
            data.Part.Color = boxColor
            data.Part.Transparency = showVisuals and visTransparency or 1

            data.GlowAdor.Visible = showVisuals and visGlowEnabled
            if data.GlowAdor.Visible then
                local mul = 1 + (visGlowIntensity-1)*9/99
                local r = math.clamp(math.floor(boxColor.R*255*mul),0,255)
                local g = math.clamp(math.floor(boxColor.G*255*mul),0,255)
                local b = math.clamp(math.floor(boxColor.B*255*mul),0,255)
                data.GlowAdor.Color3 = Color3.fromRGB(r,g,b)
                data.GlowAdor.Size = src.Size
            end
        end
    end
end)

CamTab:AddDivider()

CamTab:AddToggle("OverrideVM",{
    Text="Override Viewmodel",
    Default=false,
    Callback=function(v) overrideVM=v end
})

CamTab:AddToggle("OverrideArms",{
    Text="Override Arms",
    Default=false,
    Callback=function(v) overrideArms=v end
}):AddColorPicker("ArmsColor",{
    Default=armsColor,
    Callback=function(v) armsColor=v end
})

CamTab:AddDropdown("ArmsMat",{
    Text="Arms Material",
    Values={"Neon","ForceField","SmoothPlastic"},
    Default=3,
    Callback=function(v) armsMat=Enum.Material[v] end
})

CamTab:AddSlider("ArmsTrans",{
    Text="Arms Transparency",
    Min=0, Max=1, Default=0, Rounding=2,
    Callback=function(v) armsTrans=v end
})

CamTab:AddToggle("OverrideWeapon",{
    Text="Override Weapon",
    Default=false,
    Callback=function(v) overrideWeapon=v end
}):AddColorPicker("WeaponColor",{
    Default=weaponColor,
    Callback=function(v) weaponColor=v end
})

CamTab:AddDropdown("WeaponMat",{
    Text="Weapon Material",
    Values={"Neon","ForceField","SmoothPlastic"},
    Default=3,
    Callback=function(v) weaponMat=Enum.Material[v] end
})

CamTab:AddSlider("WeaponTrans",{
    Text="Weapon Transparency",
    Min=0, Max=1, Default=0, Rounding=2,
    Callback=function(v) weaponTrans=v end
})

local vmhighlightt = CamTab:AddToggle("VMHighlight",{
    Text="Apply Highlight",
    Default=false,
    Callback=function(v) hlEnabled=v end
}):AddColorPicker("HLFill",{
    Default=highlightFill,
    Callback=function(v) highlightFill=v end
})

vmhighlightt:AddColorPicker("HLOutline",{
    Default=highlightOutline,
    Callback=function(v) highlightOutline=v end
})

CamTab:AddSlider("HLFillTrans",{
    Text="Highlight Fill Transparency",
    Min=-20, Max=20, Default=0, Rounding=1,
    Callback=function(v) hlFillTrans=v end
})

CamTab:AddSlider("HLOutlineTrans",{
    Text="Highlight Outline Transparency",
    Min=0, Max=1, Default=0, Rounding=2,
    Callback=function(v) hlOutlineTrans=v end
})


end)
registerFuncAuto(function()

CamTab:AddDivider()
local fovToggle = CamTab:AddToggle("FOVOverride", {Text = "FOV Override", Default = false})
local fovSlider = CamTab:AddSlider("FOVValue", {Text = "FOV Override Value", Default = 120, Min = 90, Max = 120, Rounding = 1})

local zoomToggle = CamTab:AddToggle("ZoomOverride", {Text = "Zoom FOV Override", Default = false})
zoomToggle:AddKeyPicker("ZoomKey", {Text = "Zoom", Default = "None", Mode = "Toggle"})
local zoomSlider = CamTab:AddSlider("ZoomFOV", {Text = "Zoom FOV Value", Default = 10, Min = 1, Max = 70, Rounding = 1})

local scrollToggle = CamTab:AddToggle("ScrollFOV", {Text = "Scroll FOV", Default = false})
local scrollAmount = 5

local Camera = workspace.CurrentCamera


local UIS = game:GetService("UserInputService")
local zoomKeyObj = Options.ZoomKey
local scrollFOV = 90

UIS.InputChanged:Connect(function(input)
    if scrollToggle.Value and input.UserInputType == Enum.UserInputType.MouseWheel then
        local delta = input.Position.Z
        scrollFOV = math.clamp(scrollFOV - (delta * scrollAmount), 1, 120)
    end
end)

task.spawn(function()
    local RunService = game:GetService("RunService")
    while true do
        RunService.RenderStepped:Wait()
        if Library.Unloaded then break end

        local zooming = zoomToggle.Value and zoomKeyObj and zoomKeyObj:GetState()

        if zooming then
            Camera.FieldOfView = Options.ZoomFOV.Value
        elseif fovToggle.Value then
            Camera.FieldOfView = Options.FOVValue.Value
        elseif scrollToggle.Value then
            Camera.FieldOfView = scrollFOV
        else
            Camera.FieldOfView = 90
        end
    end
end)
game:GetService("RunService").RenderStepped:Connect(updateFOV)
print('\n')
print('\n')
print('\n')
print('loading \n')

end)
registerFuncAuto(function()
notifyl("ui","plr")

local carigga = files.gca("settings.png", "images")
local USettings = Window:AddTab("UI Settings", "carigga")
local MenuGroup = USettings:AddLeftGroupbox("Menu", "wrench")
MenuGroup:AddToggle("KeybindMenuOpen", {
	Default = Library.KeybindFrame.Visible,
	Text = "Open Keybind Menu",
	Callback = function(value)
		Library.KeybindFrame.Visible = value
	end,
})
MenuGroup:AddToggle("ShowCustomCursor", {
	Text = "Custom Cursor",
	Default = true,
	Callback = function(Value)
		Library.ShowCustomCursor = Value
	end,
})
MenuGroup:AddDropdown("NotificationSide", {
	Values = { "Left", "Right" },
	Default = "Right",

	Text = "Notification Side",

	Callback = function(Value)
		Library:SetNotifySide(Value)
	end,
})
MenuGroup:AddDropdown("DPIDropdown", {
	Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
	Default = "100%",

	Text = "DPI Scale",

	Callback = function(Value)
		Value = Value:gsub("%%", "")
		local DPI = tonumber(Value)

		Library:SetDPIScale(DPI)
	end,
})
MenuGroup:AddLabel("Menu bind")
	:AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })

Library.ToggleKeybind = Options.MenuKeybind
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('SOLUTIONS')
SaveManager:SetFolder('SOLUTIONS/configs')
SaveManager:BuildConfigSection(USettings)

local BUSettings = USettings:AddLeftGroupbox('Controls')
BUSettings:AddButton({
    Text = 'Copy Join Script',
    Func = function()
        local placeId = game.PlaceId
        local jobId = game.JobId

        local joinScript = string.format([[
local ts = game:GetService("TeleportService")
ts:TeleportToPlaceInstance(%d, "%s", game.Players.LocalPlayer)
]], placeId, jobId)

        setclipboard(joinScript)
        print('exact server join script copied to clipboard!')
    end,
    DoubleClick = false,
})

ThemeManager:ApplyToTab(USettings)
SaveManager:LoadAutoloadConfig()

local logoFadeDuration = 1.2
local elapsed = 0
local interval = 0.03

while elapsed < logoFadeDuration do
    local delta = interval
    local randomOffset = math.random() * 0.5
    Logo.ImageTransparency = math.clamp(elapsed / logoFadeDuration + randomOffset, 0, 1)
    task.wait(interval)
    elapsed = elapsed + delta
end

Logo:Destroy()

local bgFadeDuration = 0.8
elapsed = 0
while elapsed < bgFadeDuration do
    BlackBG.BackgroundTransparency = elapsed / bgFadeDuration
    task.wait(interval)
    elapsed = elapsed + interval
end

SplashGui:Destroy()

end)
registerFuncAuto(function()
notifyl("ui","managers")





_G.showHitmarker = function(pos)
    local hitpart = Instance.new("Part")
    hitpart.Name = "HitmarkerPart"
    hitpart.Transparency = 1
    hitpart.CanCollide = false
    hitpart.CanQuery = false
    hitpart.Size = Vector3.new(0.01, 0.01, 0.01)
    hitpart.Anchored = true
    hitpart.Position = pos
    hitpart.Parent = workspace:FindFirstChild("NoCollision")

    local hit = Instance.new("BillboardGui")
    hit.Name = "hit"
    hit.AlwaysOnTop = true
    hit.Size = UDim2.new(0, 80, 0, 80) 
    hit.StudsOffset = Vector3.new(0, 0, 0)
    hit.Parent = hitpart

    local hit_img = Instance.new("ImageLabel")
    hit_img.Name = "hit_img"
    hit_img.Image = "http://www.roblox.com/asset/?id=13298929624"
    hit_img.BackgroundTransparency = 1
    hit_img.Size = UDim2.new(0, 80, 0, 80) 
    hit_img.Visible = true
    hit_img.ImageColor3 = hitmarkerColor
    hit_img.Rotation = 45
    hit_img.AnchorPoint = Vector2.new(0.5, 0.5)
    hit_img.Position = UDim2.new(0.5, 0, 0.5, 0)
    hit_img.Parent = hit

    task.spawn(function()
        local ts = game:GetService("TweenService")
        ts:Create(hit_img, TweenInfo.new(2, Enum.EasingStyle.Sine), {ImageTransparency = 1}):Play()
        ts:Create(hit_img, TweenInfo.new(2, Enum.EasingStyle.Linear), {Rotation = 180}):Play()
        task.wait(_G.HitmarkerFade)
        if hitpart then hitpart:Destroy() end
    end)
end

local TweenService = game:GetService("TweenService")

pcallCheck(function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CurrentCamera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local FireProjectile = Remotes:WaitForChild("FireProjectile")
local ProjectileInflict = Remotes:WaitForChild("ProjectileInflict")

local function getItemRoot()
    local vm = workspace.Camera:FindFirstChild("ViewModel")
    if not vm then return nil end
    local item = vm:FindFirstChild("Item")
    if not item then return nil end
    return item.PrimaryPart
end
end)


pcall(function()
pcallCheck(function()
        local Players = game:GetService("Players")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local CurrentCamera = workspace.CurrentCamera

        local BulletModule = require(ReplicatedStorage.Modules.FPS.Bullet)
        local OriginalCreateBullet = BulletModule.CreateBullet

        local function resolveTarget()
            if not plr_target or plr_target == "" then return nil end

            local plr = Players:FindFirstChild(plr_target)
            if plr and plr.Character then
                return plr.Character:FindFirstChild("Head")
            end

            local cur = workspace
            for seg in string.gmatch(plr_target, "[^/]+") do
                cur = cur and cur:FindFirstChild(seg)
                if not cur then return nil end
            end

            return cur:IsA("BasePart") and cur or nil
        end

        local function predictVelocity(origin, destination, velocity, speed)
            local displacement = destination - origin
            local a = velocity:Dot(velocity) - speed * speed
            local b = 2 * displacement:Dot(velocity)
            local c = displacement:Dot(displacement)

            local disc = b*b - 4*a*c
            if disc < 0 then return destination end

            local t0 = (-b - math.sqrt(disc)) / (2*a)
            local t1 = (-b + math.sqrt(disc)) / (2*a)
            local t = math.max(t0, t1)
            if t < 0 then t = math.min(t0, t1) end
            if t < 0 then t = 0 end

            return destination + velocity * t
        end

        BulletModule.CreateBullet = newcclosure(function(...)
            local args = {...}

            if silent_aim.enabled and plr_target then
                local head = resolveTarget()
                if head then
                    silent_aim.target_part = head

                    local loadedammo
                    pcall(function()
                        local weapon = get_local_weapon()
                        local inv = LocalPlayer and LocalPlayer.Backpack:FindFirstChild(weapon)
                        if inv then
                            local mag = inv:FindFirstChild("Attachments") and inv.Attachments:FindFirstChild("Magazine")
                            if mag then
                                loadedammo =
                                    mag.ItemProperties
                                    and mag.ItemProperties:FindFirstChild("LoadedAmmo")
                                    and mag.ItemProperties.LoadedAmmo:FindFirstChildOfClass("Folder")
                            end
                        end
                    end)

                    local speed = loadedammo and loadedammo:GetAttribute("MuzzleVelocity") or 300
                    if type(args[5]) ~= "table" then args[5] = {} end

                    args[5].CFrame = CFrame.new(
                        CurrentCamera.CFrame.Position,
                        predictVelocity(
                            CurrentCamera.CFrame.Position,
                            head.Position,
                            head.Velocity,
                            speed
                        )
                    )

                    if silent_aim.instant then
local targetPart = silent_aim.target_part
if targetPart then
    local itemRoot = getItemRoot()
    if itemRoot then
        itemRoot.CFrame = CFrame.lookAt(itemRoot.Position, targetPart.Position)
        local shotId = math.random(-10000, 10000)

        FireProjectile:InvokeServer(Vector3.new(0/0,0/0,0/0), shotId, tick())
        ProjectileInflict:FireServer(
            targetPart,
            targetPart.CFrame:ToObjectSpace(
                CFrame.new(targetPart.Position + Vector3.new(0,0.01,0))
            ),
            shotId,
            0/0
        )
    end
end
                    end
                else
                    silent_aim.target_part = nil
                end
            else
                silent_aim.target_part = nil
            end

            return OriginalCreateBullet(table.unpack(args))
        end)
    end)
end)





end)
registerFuncAuto(function()
notifyl("logic","silent")


task.spawn(function()
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local originalWalkSpeed = 19.2

    RunService.RenderStepped:Connect(function(dt)
        if Library.Unloaded then return end
        if not speedState.enabled then return end
        if not keyObj:GetState() then return end

        local char = LocalPlayer.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not char or not hum or not hrp then return end

        local speed = sliderFlag.Value
        local typeChoice = dropdownFlag.Value

        if typeChoice == "Walkspeed" then
            hum.WalkSpeed = 16 * speed
        elseif typeChoice == "CFrame" then
            local dir = hum.MoveDirection
            if dir.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + dir * speed * dt * 20
            end
        elseif typeChoice == "TranslateBy" then
            local dir = hum.MoveDirection
            if dir.Magnitude > 0 then
                hrp:TranslateBy(dir * speed * dt * 10)
            end
        end
    end)
end)


local NoFallEnabled = false
Toggles.NoFallToggle:OnChanged(function(Value)
    NoFallEnabled = Value
end)

local player = game:GetService("Players").LocalPlayer
local character = player.Character
local humanoid = character:FindFirstChildOfClass('Humanoid')
local rootPart = character:FindFirstChild('HumanoidRootPart')
RunService = game:GetService("RunService")
RunService.Heartbeat:Connect(function()
    if not NoFallEnabled then return end

    if not character then return end
    if not humanoid or not rootPart then return end

    local state = humanoid:GetState()
    if state == Enum.HumanoidStateType.Freefall then
        local velY = rootPart.AssemblyLinearVelocity.Y
        if velY < -12.5 then
            humanoid:ChangeState(Enum.HumanoidStateType.Landed)
        end
    end
end)

pcall(function() local plr=game.Players.LocalPlayer local ws=game:GetService("Workspace") local function h() local c=plr.Character local hum=c and c:FindFirstChild("Humanoid") if not hum then c=plr.CharacterAdded:Wait() hum=c:WaitForChild("Humanoid") end return hum end local hum=h() local conns={{'CharacterController',hum:GetPropertyChangedSignal('WalkSpeed')},{'CharacterController',hum:GetPropertyChangedSignal('JumpHeight')},{'CharacterController',hum:GetPropertyChangedSignal('HipHeight')},{'CharacterController',ws:GetPropertyChangedSignal('Gravity')},{'CharacterController',hum.StateChanged},{'CharacterController',hum.ChildAdded},{'CharacterController',hum.ChildRemoved}} local function d() for _,arr in ipairs(conns)do for _,conn in ipairs(getconnections(arr[2]))do if type(conn.Function)=="function"then local info=debug.getinfo(conn.Function) if info and string.find(info.source,arr[1])then conn:Disable()end end end end end d() plr.CharacterAdded:Connect(function(c) hum=c:WaitForChild("Humanoid") d() end) end)
end)
registerFuncAuto(function()
notifyl("logic","speedhack")



end)
registerFuncAuto(function()
notifyl("logic","chams")

local esp_screen=Instance.new("ScreenGui")
esp_screen.Name="ESP_Screen"
esp_screen.Parent=game:GetService("CoreGui")
esp_screen.ResetOnSpawn=false
esp_screen.IgnoreGuiInset=true
esp_screen.DisplayOrder=999999
local esp_folder=Instance.new("Folder")
esp_folder.Name="ESP_Objects"
esp_folder.Parent=esp_screen

local esp_objects={}
local STUDS_HEIGHT,STUDS_WIDTH,box_scale=5.5,4,6
local function project(pos)
 local v,onScreen=Camera:WorldToViewportPoint(pos)
 return Vector2.new(v.X,v.Y),onScreen
end

local function formatName(name)
 if casingMode=="Lowercase" then return string.lower(name)
 elseif casingMode=="Uppercase" then return string.upper(name)
 else return name end
end

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Camera = workspace.CurrentCamera
LocalPlayer = Players.LocalPlayer

local function create_esp(player)
 if esp_objects[player] then return end
 local container=Instance.new("Frame")
 container.BackgroundTransparency=1
 container.BorderSizePixel=0
 container.Visible=false
 container.ZIndex=1
 container.Parent=esp_folder

 local box=Instance.new("Frame")
 box.Size=UDim2.new(1,0,1,0)
 box.BackgroundTransparency=1
 box.BorderSizePixel=0
 box.ZIndex=2
 box.Parent=container

 local stroke_outline=Instance.new("UIStroke")
 stroke_outline.Color=Color3.new(0,0,0)
 stroke_outline.Thickness=1
 stroke_outline.LineJoinMode=Enum.LineJoinMode.Miter
 stroke_outline.BorderOffset=UDim.new(0,0)
 stroke_outline.ZIndex=4
 stroke_outline.Parent=box

 local stroke_fill=Instance.new("UIStroke")
 stroke_fill.Color=Color3.new(1,1,1)
 stroke_fill.Thickness=2
 stroke_fill.LineJoinMode=Enum.LineJoinMode.Miter
 stroke_fill.BorderOffset=UDim.new(0,1)
 stroke_fill.ZIndex=2
 stroke_fill.Parent=box

 local stroke_inline=Instance.new("UIStroke")
 stroke_inline.Color=Color3.new(0,0,0)
 stroke_inline.Thickness=1
 stroke_inline.LineJoinMode=Enum.LineJoinMode.Miter
 stroke_inline.BorderOffset=UDim.new(0,2)
 stroke_inline.ZIndex=3
 stroke_inline.Parent=box

 local boxGradient=Instance.new("UIGradient")
 boxGradient.Rotation=90
 boxGradient.Color=ColorSequence.new(boxTopColor,boxBotColor)
 boxGradient.Parent=stroke_fill

 local name=Instance.new("TextLabel")
 name.AnchorPoint=Vector2.new(0.5,1)
 name.Position=UDim2.new(0.5,0,0,-4)
 name.Size=UDim2.new(1,20,0,14)
 name.BackgroundTransparency=1
 name.TextScaled=false
 name.TextSize=name_size
 name.TextColor3=nameColor
 name.FontFace=nametagFont
 name.Text=player.Name
 name.ZIndex=5
 name.Parent=container

 local nameStroke=Instance.new("UIStroke")
 nameStroke.Color=Color3.new(0,0,0)
 nameStroke.Thickness=1
 nameStroke.Parent=name

 local holder=Instance.new("Frame")
 holder.BackgroundTransparency=1
 holder.Size=UDim2.new(0,3,1,6)
 holder.AnchorPoint=Vector2.new(1,1)
 holder.Position=UDim2.new(0,-4,1,3)
 holder.ZIndex=5
 holder.Parent=container

 local healthbar=Instance.new("Frame")
 healthbar.BackgroundTransparency=1
 healthbar.Size=UDim2.new(1,-2,1,-2)
 healthbar.Position=UDim2.new(1,-2,1,-1)
 healthbar.AnchorPoint=Vector2.new(0,1)
 healthbar.ZIndex=6
 healthbar.Parent=holder

 local bar=Instance.new("Frame")
 bar.Size=UDim2.new(1,0,1,0)
 bar.Position=UDim2.new(0,0,0,0)
 bar.BackgroundColor3=Color3.new(1,1,1)
 bar.ZIndex=6
 bar.Parent=healthbar

 local barGradient=Instance.new("UIGradient")
 barGradient.Rotation=90
 barGradient.Color=ColorSequence.new(hpTopColor,hpBotColor)
 barGradient.Parent=bar

 local boxFill = Instance.new("Frame")
boxFill.Size = UDim2.new(1,0,1,0)
boxFill.BackgroundTransparency = 1
boxFill.BorderSizePixel = 0
boxFill.ZIndex = 1
boxFill.Parent = container

local boxFillGradient = Instance.new("UIGradient")
boxFillGradient.Rotation = 90
boxFillGradient.Color = ColorSequence.new(
    Color3.fromRGB(255,255,255),
    Color3.fromRGB(0,0,0)
)
boxFillGradient.Parent = boxFill

 local flag=Instance.new("TextLabel")
 flag.Size=UDim2.new(0,15,0,name_size-3)
 flag.Position=UDim2.new(0,-2,0,0)
 flag.AnchorPoint=Vector2.new(1,0)
 flag.TextSize=name_size-3
 flag.TextColor3=hpTopColor
 flag.FontFace=nametagFont
 flag.BackgroundTransparency=1
 flag.Text="100"
 flag.ZIndex=7
 flag.Parent=holder

 local flagStroke=Instance.new("UIStroke")
 flagStroke.Color=Color3.new(0,0,0)
 flagStroke.Thickness=1
 flagStroke.Parent=flag

 local flagsContainer = Instance.new("Frame")
 flagsContainer.BackgroundTransparency = 1
 flagsContainer.AnchorPoint = Vector2.new(0,0)
 flagsContainer.Position = UDim2.new(1,-2,0,0)
 flagsContainer.Size = UDim2.new(0,50,0,name_size)
 flagsContainer.ZIndex = 7
 flagsContainer.Parent = container

 local flagsLayout = Instance.new("UIListLayout")
 flagsLayout.FillDirection = Enum.FillDirection.Vertical
 flagsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
 flagsLayout.VerticalAlignment = Enum.VerticalAlignment.Top
 flagsLayout.SortOrder = Enum.SortOrder.LayoutOrder
 flagsLayout.Parent = flagsContainer

 local visibleFlag = Instance.new("TextLabel")
 visibleFlag.Size = UDim2.new(1,0,0, name_size-3)
 visibleFlag.BackgroundTransparency = 1
 visibleFlag.FontFace = nametagFont
 visibleFlag.TextSize = name_size-3
 visibleFlag.TextColor3 = nameColor
 visibleFlag.Text = "Visible"
 visibleFlag.Visible = false
 visibleFlag.ZIndex = 8
 visibleFlag.Parent = flagsContainer

 local visibleStroke = Instance.new("UIStroke")
visibleStroke.Color = Color3.new(0,0,0)
visibleStroke.Thickness = 1
visibleStroke.Parent = visibleFlag

local invisibleFlag = Instance.new("TextLabel")
invisibleFlag.Size = UDim2.new(1,0,0, name_size-3)
invisibleFlag.BackgroundTransparency = 1
invisibleFlag.FontFace = nametagFont
invisibleFlag.TextSize = name_size-3
invisibleFlag.TextColor3 = nameColor
invisibleFlag.Text = "Hidden"
invisibleFlag.Visible = false
invisibleFlag.ZIndex = 8
invisibleFlag.Parent = flagsContainer

local invisibleStroke = Instance.new("UIStroke")
invisibleStroke.Color = Color3.new(0,0,0)
invisibleStroke.Thickness = 1
invisibleStroke.Parent = invisibleFlag

local itemFlag = Instance.new("TextLabel")
itemFlag.AnchorPoint = Vector2.new(0.5,0)
itemFlag.Position = UDim2.new(0.5,0,1,4)
itemFlag.Size = UDim2.new(1,20,0,name_size-2)
itemFlag.BackgroundTransparency = 1
itemFlag.TextSize = name_size-2
itemFlag.FontFace = nametagFont
itemFlag.TextColor3 = nameColor
itemFlag.Text = ""
itemFlag.Visible = false
itemFlag.ZIndex = 6
itemFlag.Parent = container

local itemStroke = Instance.new("UIStroke")
itemStroke.Color = Color3.new(0,0,0)
itemStroke.Thickness = 1
itemStroke.Parent = itemFlag

local godmodeFlag = Instance.new("TextLabel")
godmodeFlag.Size = UDim2.new(1,0,0, name_size-3)
godmodeFlag.BackgroundTransparency = 1
godmodeFlag.FontFace = nametagFont
godmodeFlag.TextSize = name_size-3
godmodeFlag.TextColor3 = Color3.fromRGB(255, 255, 255)
godmodeFlag.Text = "Godmode"
godmodeFlag.Visible = false
godmodeFlag.ZIndex = 8
godmodeFlag.Parent = flagsContainer

local godmodeStroke = Instance.new("UIStroke")
godmodeStroke.Color = Color3.new(0,0,0)
godmodeStroke.Thickness = 1
godmodeStroke.Parent = godmodeFlag


esp_objects[player] = {
    container = container,
    box = box,
    fill = stroke_fill,
    inline = stroke_inline,
    outline = stroke_outline,
    boxGradient = boxGradient,

    boxFill = boxFill,
    boxFillGradient = boxFillGradient,

    name = name,
    nameStroke = nameStroke,

    holder = holder,
    healthbar = healthbar,
    bar = bar,
    barGradient = barGradient,
    flag = flag,
    flagStroke = flagStroke,

    flagsContainer = flagsContainer,
    visibleFlag = visibleFlag,
    invisibleFlag = invisibleFlag,

    itemFlag = itemFlag,
    itemStroke = itemStroke,

    godmodeFlag = godmodeFlag,
    godmodeStroke = godmodeStroke,
}

end

local function remove_esp(player)
 if esp_objects[player] then
  esp_objects[player].container:Destroy()
  esp_objects[player]=nil
 end
end

for _,p in ipairs(Players:GetPlayers()) do if p~=LocalPlayer then create_esp(p) end end
Players.PlayerAdded:Connect(function(p) if p~=LocalPlayer then create_esp(p) end end)
Players.PlayerRemoving:Connect(remove_esp)

local rayParams = RaycastParams.new()
rayParams.FilterType = Enum.RaycastFilterType.Blacklist
rayParams.IgnoreWater = true

RunService.RenderStepped:Connect(function()
    local hue = tick() % 5 / 5
    local camPos = Camera.CFrame.Position
    local localChar = LocalPlayer.Character

    for player, esp in pairs(esp_objects) do
        local char = player.Character
        local hum = char and char:FindFirstChild("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local head = char and char:FindFirstChild("Head")

        if not (char and hum and hrp) then
            esp.container.Visible = false
            continue
        end

        local top = hrp.Position + Vector3.new(0, STUDS_HEIGHT / 2, 0)
        local bottom = hrp.Position - Vector3.new(0, STUDS_HEIGHT / 2, 0)

        local top2D, topVis = project(top)
        local bot2D, botVis = project(bottom)

        if not (topVis and botVis) then
            esp.container.Visible = false
            continue
        end

        local dist = (camPos - hrp.Position).Magnitude
        local width = STUDS_WIDTH / dist * 100 * box_scale
        local height = bot2D.Y - top2D.Y

        esp.container.Size = UDim2.new(0, width, 0, height)
        esp.container.Position = UDim2.new(0, top2D.X - width / 2, 0, top2D.Y)
        esp.container.Visible = true

        esp.box.Visible = boxEspEnabled
        esp.boxGradient.Color = rainbowBox
            and ColorSequence.new(
                Color3.fromHSV(hue, 1, 1),
                Color3.fromHSV((hue + 0.3) % 1, 1, 1)
            )
            or ColorSequence.new(boxTopColor, boxBotColor)

        esp.boxFill.Visible = boxFillEnabled
if esp.boxFill and esp.boxFillGradient then
    esp.boxFill.Visible = boxFillEnabled
    esp.boxFillGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, boxFillTopColor, boxFillTopTrans),
        ColorSequenceKeypoint.new(1, boxFillBotColor, boxFillBotTrans)
    })
    esp.boxFill.BackgroundTransparency = boxFillEnabled and 0 or 1
end

esp.boxFill.BackgroundTransparency = boxFillEnabled and 0 or 1
esp.boxFillGradient.Rotation = 90
esp.boxFill.BackgroundTransparency = 1 - ((boxFillTopTrans + boxFillBotTrans)/2)

        esp.name.Visible = nameEspEnabled
        esp.name.Text = formatName(player.Name)
        esp.name.TextSize = name_size
        esp.name.FontFace = nametagFont
        esp.name.TextColor3 = rainbowName and Color3.fromHSV(hue, 1, 1) or nameColor

        local desiredFont = nametagFont
        local desiredColor = rainbowName and Color3.fromHSV(hue, 1, 1) or nameColor

if esp._lastFont ~= desiredFont then
    esp._lastFont = desiredFont
    esp.flag.FontFace = desiredFont
    esp.itemFlag.FontFace = desiredFont
    esp.visibleFlag.FontFace = desiredFont
    esp.invisibleFlag.FontFace = desiredFont
    esp.godmodeFlag.FontFace = desiredFont
end
if esp._lastColor ~= desiredColor then
    esp._lastColor = desiredColor
    esp.itemFlag.TextColor3 = desiredColor
    esp.visibleFlag.TextColor3 = desiredColor
    esp.invisibleFlag.TextColor3 = desiredColor
    esp.godmodeFlag.TextColor3 = desiredColor
end

        local hpPercent = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
        esp.bar.Visible = hpBarEnabled
        esp.bar.Size = UDim2.new(1, 0, hpPercent, 0)
        esp.bar.Position = UDim2.new(0, 0, 1 - hpPercent, 0)
        esp.barGradient.Color = rainbowHP
            and ColorSequence.new(
                Color3.fromHSV(hue, 1, 1),
                Color3.fromHSV((hue + 0.3) % 1, 1, 1)
            )
            or ColorSequence.new(hpTopColor, hpBotColor)

        esp.flag.Visible = hpFlagEnabled
        esp.flag.Text = tostring(math.floor(hum.Health))
        esp.flag.TextSize = name_size - 3
        esp.flag.TextColor3 = hpTopColor
        esp.godmodeFlag.TextSize = name_size - 3

        if hpFlagPosition == "Following" then
            esp.flag.Position = UDim2.new(0, -2, 1 - hpPercent, 0)
        else
            esp.flag.Position = UDim2.new(0, -2, 0, 0)
        end

local holding = char:FindFirstChild("Holding")
local equippedName = nil

if holding and holding:IsA("ObjectValue") and holding.Value then
    equippedName = holding.Value.Name
end

if itemFlagEnabled then
    if esp._lastEquipped ~= equippedName then
        esp._lastEquipped = equippedName
        if equippedName then
            esp.itemFlag.Text = equippedName
            esp.itemFlag.Visible = true
        else
            esp.itemFlag.Visible = false
        end
    end
else
    esp.itemFlag.Visible = false
end


        esp.itemFlag.TextSize = name_size - 3

        rayParams.FilterDescendantsInstances = { char, localChar }

        local target = head or hrp
        local direction = target.Position - camPos
        local result = workspace:Raycast(camPos, direction, rayParams)

        local isVisible
        if result then
            isVisible = result.Instance:IsDescendantOf(char)
        else
            isVisible = true
        end

        esp.visibleFlag.Visible = isVisible and visibleFlagEnabled
        esp.invisibleFlag.Visible = (not isVisible) and invisibleFlagEnabled
        local torso =
    char:FindFirstChild("UpperTorso")
    or char:FindFirstChild("Torso")

local hasInfiniteHealth =
    hum.Health == math.huge
    or hum.MaxHealth == math.huge

local hasForcefieldTorso =
    torso and torso.Material == Enum.Material.ForceField

local isGodmode = hasInfiniteHealth or hasForcefieldTorso

esp.godmodeFlag.Visible = isGodmode and godmodeFlagEnabled

    end
end)


ChamData = {}


ChamsEnabled = false
HighlightOn = true
BoxesOn = false
GlowOn = false
FillTrans = 0.5
OutlineTrans = 0
FillColor = Color3.fromRGB(255,255,255)
OutlineColor = Color3.fromRGB(255,255,255)
GlowColor = Color3.fromRGB(255,255,255)
GlowIntensity = 10

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local R6Limbs = {"Head","Torso","Left Arm","Right Arm","Left Leg","Right Leg"}
local R15Limbs = {"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand",
                   "RightUpperArm","RightLowerArm","RightHand","LeftUpperLeg","LeftLowerLeg",
                   "LeftFoot","RightUpperLeg","RightLowerLeg","RightFoot"}

local function GetLimbList(char)
    if char:FindFirstChild("Humanoid") then
        if char.Humanoid.RigType == Enum.HumanoidRigType.R15 then
            return R15Limbs
        else
            return R6Limbs
        end
    end
    return R6Limbs
end

local function UpdateChamsForAll()
    for plr, data in pairs(ChamData) do
        if data.Highlight then
            data.Highlight.Enabled = ChamsEnabled and HighlightOn
            data.Highlight.FillColor = FillColor
            data.Highlight.OutlineColor = OutlineColor
            data.Highlight.FillTransparency = FillTrans
            data.Highlight.OutlineTransparency = OutlineTrans
        end

        if data.Box then
            for _, box in pairs(data.Box) do
                box.Visible = ChamsEnabled and BoxesOn
                box.Color3 = FillColor
                box.Transparency = FillTrans
            end
        end

        if data.Glow then
            for _, g in pairs(data.Glow) do
                g.Ador.Visible = ChamsEnabled and GlowOn
                local r = math.floor(GlowColor.R*255 * (1 + (GlowIntensity-1)*9/99))
                local g_val = math.floor(GlowColor.G*255 * (1 + (GlowIntensity-1)*9/99))
                local b = math.floor(GlowColor.B*255 * (1 + (GlowIntensity-1)*9/99))
                g.Ador.Color3 = Color3.fromRGB(r, g_val, b)
                g.Ador.Shading = _G.SHADING_TYPE
            end
        end
    end
end

local function SetupGlowForCharacter(char, limbs)
    local GlowParts = {}
    local function recurse(part)
        if part:IsA("BasePart") or part:IsA("MeshPart") then
            for _, l in pairs(limbs) do
                if part.Name == l then
                    local adorn = Instance.new("BoxHandleAdornment")
                    adorn.Size = part.Size
                    adorn.Adornee = part
                    local r = math.floor(GlowColor.R*255 * (1 + (GlowIntensity-1)*9/99))
                    local g_val = math.floor(GlowColor.G*255 * (1 + (GlowIntensity-1)*9/99))
                    local b = math.floor(GlowColor.B*255 * (1 + (GlowIntensity-1)*9/99))
                    adorn.Color3 = Color3.fromRGB(r, g_val, b)
                    adorn.ZIndex = -1
                    adorn.AlwaysOnTop = true
                    adorn.Shading = _G.SHADING_TYPE
                    adorn.Visible = ChamsEnabled and GlowOn
                    adorn.Parent = part
                    table.insert(GlowParts, {Part=part, Ador=adorn})
                    break
                end
            end
        end
        for _, c in pairs(part:GetChildren()) do recurse(c) end
    end
    recurse(char)
    return GlowParts
end

local function SetupChamsForCharacter(plr, char)
    repeat task.wait() until char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid")
    local limbs = GetLimbList(char)

    if ChamData[plr] then
        local prev = ChamData[plr]
        if prev.Highlight then prev.Highlight:Destroy() end
        if prev.Box then for _, b in pairs(prev.Box) do b:Destroy() end end
        if prev.Glow then for _, g in pairs(prev.Glow) do if g.Ador then g.Ador:Destroy() end end end
    end

    local h = Instance.new("Highlight")
    h.Adornee = char
    h.FillColor = FillColor
    h.OutlineColor = OutlineColor
    h.FillTransparency = FillTrans
    h.OutlineTransparency = OutlineTrans
    h.Enabled = ChamsEnabled and HighlightOn
    h.Parent = workspace

    local Boxes = {}
    for _, limbName in pairs(limbs) do
        local part = char:FindFirstChild(limbName)
        if part and part:IsA("BasePart") then
            local box = Instance.new("BoxHandleAdornment")
            box.Size = part.Size
            box.Adornee = part
            box.ZIndex = 3
            box.AlwaysOnTop = true
            box.Visible = ChamsEnabled and BoxesOn
            box.Color3 = FillColor
            box.Transparency = FillTrans
            box.Parent = part
            table.insert(Boxes, box)
        end
    end

    local GlowParts = SetupGlowForCharacter(char, limbs)
    ChamData[plr] = {Highlight=h, Box=Boxes, Glow=GlowParts}
    UpdateChamsForAll()
end

local function ApplyChamsToPlayer(plr)
    if plr ~= LocalPlayer then
        local function setupChar(char)
            SetupChamsForCharacter(plr, char)
        end
        if plr.Character then
            setupChar(plr.Character)
        end
        plr.CharacterAdded:Connect(function(char)
            task.wait(0.5)
            setupChar(char)
        end)
    end
end

for _, plr in pairs(Players:GetPlayers()) do
    ApplyChamsToPlayer(plr)
end

Players.PlayerAdded:Connect(function(plr)
    ApplyChamsToPlayer(plr)
end)

RunService.RenderStepped:Connect(function()
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and not ChamData[plr] then
            SetupChamsForCharacter(plr, plr.Character)
        end
    end
end)


local Group = SubChamsPersonal

local GlowChamsFixToggle
local ThresholdSlider
local SizeSlider
local IntensitySlider

local Lighting = game:GetService("Lighting")
local bloom = Lighting:FindFirstChildOfClass("BloomEffect")
local bloomExisted = true
local oldSettings = {}

if not bloom then
    bloom = Instance.new("BloomEffect")
    bloom.Parent = Lighting
    bloomExisted = false
end

oldSettings.Threshold = bloom.Threshold
oldSettings.Size = bloom.Size
oldSettings.Intensity = bloom.Intensity

GlowChamsFixToggle = Group:AddToggle("GlowChamsFix", {
    Text = "Glowchams Fix",
    Default = false,
    Callback = function(val)
        if val then
            bloom.Threshold = ThresholdSlider.Value
            bloom.Size = SizeSlider.Value
            bloom.Intensity = IntensitySlider.Value
        else
            if bloomExisted then
                bloom.Threshold = oldSettings.Threshold
                bloom.Size = oldSettings.Size
                bloom.Intensity = oldSettings.Intensity
            else
                bloom:Destroy()
            end
        end
    end
})

ThresholdSlider = Group:AddSlider("GlowThreshold", {
    Text = "Bloom Threshold",
    Default = 0.8,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(val)
        if GlowChamsFixToggle.Value then
            bloom.Threshold = val
        end
    end
})

SizeSlider = Group:AddSlider("GlowSize", {
    Text = "Bloom Size",
    Default = 56,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(val)
        if GlowChamsFixToggle.Value then
            bloom.Size = val
        end
    end
})

IntensitySlider = Group:AddSlider("GlowIntensity", {
    Text = "Bloom Intensity",
    Default = 0.6,
    Min = 0,
    Max = 5,
    Rounding = 2,
    Callback = function(val)
        if GlowChamsFixToggle.Value then
            bloom.Intensity = val
        end
    end
})




end)
registerFuncAuto(function()
notifyl("logic","esp")

finishLoading()
end)

loadfunc()
