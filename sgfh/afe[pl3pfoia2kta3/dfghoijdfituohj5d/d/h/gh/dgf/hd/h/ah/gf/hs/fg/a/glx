warn("r")
local funcsToLoad = {}
local autoFuncId = 0

function registerFuncAuto(fn)
    autoFuncId = autoFuncId + 1
    funcsToLoad[#funcsToLoad + 1] = {name="func"..autoFuncId, fn=fn}
end

function loadfunc()
    for _, f in ipairs(funcsToLoad) do
        f.fn()
    end
end


registerFuncAuto(function()


print('\n')
print('\n')
print('\n')
print('file imports \n')
files = loadstring(game:HttpGet("https://raw.githubusercontent.com/petal-cymk/assets/refs/heads/main/import.lua"))()
files.import("logo.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/_peak.png")
files.import("visual.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/download%20(3)%20(1)%20(1).png")
files.import("combat.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/maio%20%F0%9F%90%B1%20(1).png")
files.import("player.png", "images", "https://raw.githubusercontent.com/petal-cymk/assets/main/download%20(4)%20(1)%20(1).png")

print('break \n')
print('\n')
print('\n')
print('\n')
repo='https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/'

Library=loadstring(game:HttpGet(repo..'Library.lua'))()
ThemeManager=loadstring(game:HttpGet(repo..'addons/ThemeManager.lua'))()
SaveManager=loadstring(game:HttpGet(repo..'addons/SaveManager.lua'))()
Options = Library.Options
Toggles = Library.Toggles
current_load = 0
max_load = 7
Library.ForceCheckbox = true


function notifyl(section, type)
    current_load = current_load + 1
    local description = string.format("%d / %d | %s", current_load, max_load, type)
    Library:Notify({
        Title = section,
        Description = description,
        Time = 5,
    })
    print(string.format("%d / %d | %s %s loaded.\n", current_load, max_load, section, type))
end

function finishLoading()
    local description = "finished loading solutions.gg."
    Library:Notify({
        Title = string.format("%d / %d", max_load, max_load),
        Description = description,
        Time = 5,
    })
    print(string.format("%d / %d | %s\n", max_load, max_load, description))
end

local RunService = game:GetService("RunService")

local Camera = workspace:WaitForChild("Camera")

local armsColor = Color3.new(1,1,1)
local weaponColor = Color3.new(1,1,1)
local highlightFill = Color3.new(1,1,1)
local highlightOutline = Color3.new(1,1,1)

local overrideVM = false
local overrideArms = false
local overrideWeapon = false
local armsMat = Enum.Material.SmoothPlastic
local weaponMat = Enum.Material.SmoothPlastic
local armsTrans = 0
local weaponTrans = 0
local hlEnabled = false
local hlFillTrans = 0
local hlOutlineTrans = 0

local function getParts(vm)
    local arms = {}
    local weapon = {}
    local item = vm:FindFirstChild("Item")

    for _,v in ipairs(vm:GetDescendants()) do
        if v:IsA("BasePart") then
            if item and v:IsDescendantOf(item) then
                table.insert(weapon,v)
            else
                table.insert(arms,v)
            end
        end
    end

    return arms, weapon
end

local function apply(vm)
    if not overrideVM or not vm then return end

    for _,v in ipairs(vm:GetDescendants()) do
        if v:IsA("BasePart") then
            for _,sa in ipairs(v:GetChildren()) do
                if sa:IsA("SurfaceAppearance") then
                    sa:Destroy()
                end
            end
        end
    end

    local arms, weapon = getParts(vm)

    if overrideArms then
        for _,p in ipairs(arms) do
            if p.Transparency < 0.99 then
                p.Color = armsColor
                p.Material = armsMat
                p.Transparency = armsTrans
            end
        end
    end

    if overrideWeapon then
        for _,p in ipairs(weapon) do
            if p.Transparency < 0.99 then
                p.Color = weaponColor
                p.Material = weaponMat
                p.Transparency = weaponTrans
            end
        end
    end

    if hlEnabled then
        local h = vm:FindFirstChild("VMHighlight") or Instance.new("Highlight", vm)
        h.Name = "VMHighlight"
        h.FillColor = highlightFill
        h.OutlineColor = highlightOutline
        h.FillTransparency = math.clamp(hlFillTrans, -20, 20)
        h.OutlineTransparency = math.clamp(hlOutlineTrans, 0, 1)
    else
        local h = vm:FindFirstChild("VMHighlight")
        if h then h:Destroy() end
    end
end

spawn(function()
    while true do
        local vm = Camera:FindFirstChild("ViewModel")
        if vm then
            apply(vm)
        end
        wait(0.05)
    end
end)


targeting_flags = {
    enabled = false,
    mitarget = false,
    fov_radius = 200,
    gradient_rot = 0,
    col_a = Color3.fromRGB(255,255,255),
    col_b = Color3.fromRGB(255,255,255),
    render_inner = true,
    render_middle = true,
    render_outline = true,
    target_players = true
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local LocalPlayer = Players.LocalPlayer
local Mouse = Players.LocalPlayer:GetMouse()

local gui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
gui.Name = "FOV_Circle_GUI"

local fov = Instance.new("Frame", gui)
fov.Size = UDim2.new(0, targeting_flags.fov_radius, 0, targeting_flags.fov_radius)
fov.Position = UDim2.new(0.5,0,0.5,0)
fov.AnchorPoint = Vector2.new(0.5,0.5)
fov.BackgroundTransparency = 1
fov.BorderSizePixel = 0
fov.Visible = targeting_flags.enabled

local corner = Instance.new("UICorner", fov)
corner.CornerRadius = UDim.new(1,8)

local stroke_inner = Instance.new("UIStroke", fov)
stroke_inner.Thickness = 1
stroke_inner.Color = Color3.new(0,0,0)
stroke_inner.ZIndex = 1
stroke_inner.Enabled = targeting_flags.render_inner

local fillStroke = Instance.new("UIStroke", fov)
fillStroke.Thickness = 1.5
fillStroke.Color = Color3.new(1,1,1)
fillStroke.BorderOffset = UDim.new(0,1)
fillStroke.ZIndex = 1
fillStroke.Enabled = targeting_flags.render_middle

local gradient = Instance.new("UIGradient", fillStroke)
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, targeting_flags.col_a),
    ColorSequenceKeypoint.new(1, targeting_flags.col_b)
}
gradient.Rotation = targeting_flags.gradient_rot

local outlineStroke = Instance.new("UIStroke", fov)
outlineStroke.Thickness = 1
outlineStroke.Color = Color3.new(0,0,0)
outlineStroke.BorderOffset = UDim.new(0,2.5)
outlineStroke.ZIndex = 2
outlineStroke.Enabled = targeting_flags.render_outline

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

plr_target = nil

RunService.RenderStepped:Connect(function()
    if not targeting_flags.enabled then
        plr_target = nil
        return
    end

    local closest = nil
    local shortest = targeting_flags.fov_radius

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and targeting_flags.target_players then
            local char = plr.Character
            local head = char and char:FindFirstChild("Head")
            local hum = char and char:FindFirstChild("Humanoid")
            if head and hum and hum.Health > 0 then
                local pos, onscreen = workspace.CurrentCamera:WorldToViewportPoint(head.Position)
                if onscreen then
                    local dist = (Vector2.new(pos.X,pos.Y)-Vector2.new(Mouse.X,Mouse.Y)).Magnitude
                    if dist < shortest then
                        shortest = dist
                        closest = head
                    end
                end
            end
        end
    end

    if targeting_flags.mitarget then
        local mi24part = workspace:FindFirstChild("AiZones")
                        and workspace.AiZones:FindFirstChild("HeliAirfield")
                        and workspace.AiZones.HeliAirfield:FindFirstChild("MI24V")
                        and workspace.AiZones.HeliAirfield.MI24V:FindFirstChild("Pilots")
                        and workspace.AiZones.HeliAirfield.MI24V.Pilots:FindFirstChild("CollisionPilot")

        if mi24part then
            local pos, onscreen = workspace.CurrentCamera:WorldToViewportPoint(mi24part.Position)
            if onscreen then
                local dist = (Vector2.new(pos.X,pos.Y)-Vector2.new(Mouse.X,Mouse.Y)).Magnitude
                if dist < shortest then
                    shortest = dist
                    closest = mi24part
                end
            end
        end
    end

    plr_target = closest
end)






local TargetLabel = Library:AddDraggableLabel("target = nil")

task.spawn(function()
    while task.wait(0.1) do
        local targetName = "nil"
        local color = Color3.fromRGB(255, 255, 255)

        if typeof(plr_target) == "Instance" and plr_target:IsA("BasePart") then
            local character = plr_target.Parent
            if character then
                local player = Players:GetPlayerFromCharacter(character)
                if player then
                    targetName = player.Name
                    color = Color3.fromRGB(0, 255, 0)
                end
            end
        end

        TargetLabel:SetText("target = " .. targetName)
    end
end)



local Players=game:GetService("Players")
local LocalPlayer=Players.LocalPlayer
local Camera=workspace.CurrentCamera
local RunService=game:GetService("RunService")
local HttpService=game:GetService("HttpService")

local Fonts={}
local FontNames={Minecraftia="minecraftia.ttf",Tahoma="fs-tahoma-8px.ttf"}
local function RegisterFont(Name,Asset)
 if not isfile(Asset.Id) then writefile(Asset.Id,Asset.Font) end
 if isfile(Name..".font") then delfile(Name..".font") end
 local Data={name=Name,faces={{name="Normal",weight=400,style="Normal",assetId=getcustomasset(Asset.Id)}}}
 writefile(Name..".font",HttpService:JSONEncode(Data))
 return getcustomasset(Name..".font")
end
for name,file in pairs(FontNames) do
 local asset=game:HttpGet("https://raw.githubusercontent.com/petal-cymk/assets/main/fonts/"..file)
 Fonts[name]=Font.new(RegisterFont(name,{Id=file,Font=asset}),Enum.FontWeight.Regular,Enum.FontStyle.Normal)
end
local logorb = files.gca("logo.png", "images")
Window = Library:CreateWindow({
	Title = "solutions.gg",
	Footer = "the only real free option.",
	Icon = logorb,
	NotifySide = "Right",
	ShowCustomCursor = true,
})
local visl = files.gca("visual.png", "images")
Tabs={Main=Window:AddTab("Visual", visl)}

local ESPSubtab=Tabs.Main:AddLeftTabbox()
SubESP=ESPSubtab:AddTab("ESP")
SubPersonal=ESPSubtab:AddTab("Personalisation")

local ChamSubtab=Tabs.Main:AddRightTabbox() 
SubChams=ChamSubtab:AddTab("Chams") 
SubChamsPersonal=ChamSubtab:AddTab("Personalisation")


boxEspEnabled,nameEspEnabled,hpBarEnabled,hpFlagEnabled=false,false,false,false
rainbowBox,rainbowName,rainbowHP=false,false,false
name_size=10
nametagFont=Fonts.Minecraftia
boxTopColor,boxBotColor,nameColor,hpTopColor,hpBotColor=Color3.new(1,1,1),Color3.new(1,1,1),Color3.new(1,1,1),Color3.fromRGB(0,255,0),Color3.fromRGB(255,0,0)
hpFlagPosition="Following"
casingMode="Titlecase"

SubESP:AddToggle("BoxESP",{Text="Box ESP",Default=false,Callback=function(v) boxEspEnabled=v end})
SubESP:AddToggle("NameESP",{Text="Nametag ESP",Default=false,Callback=function(v) nameEspEnabled=v end})
SubESP:AddToggle("HPBar",{Text="HP Bar",Default=false,Callback=function(v) hpBarEnabled=v end})
SubESP:AddToggle("HPFlag",{Text="HP Flag",Default=false,Callback=function(v) hpFlagEnabled=v end})

SubPersonal:AddSlider("NameSize",{Text="Name Size",Min=6,Max=40,Default=name_size,Rounding=0,Callback=function(v) name_size=v end})
SubPersonal:AddDropdown("NameFont",{Values={"Minecraftia","Tahoma"},Default=1,Text="Nametag Font",Callback=function(val) nametagFont=Fonts[val] end})
SubPersonal:AddDropdown("NameCase",{Values={"Lowercase","Uppercase","Titlecase"},Default=3,Text="Nametag Casing",Callback=function(v) casingMode=v end})
SubPersonal:AddToggle("RainbowBox",{Text="Rainbow Box",Default=false,Callback=function(v) rainbowBox=v end})
SubPersonal:AddToggle("RainbowName",{Text="Rainbow Nametag",Default=false,Callback=function(v) rainbowName=v end})
SubPersonal:AddToggle("RainbowHP",{Text="Rainbow HP",Default=false,Callback=function(v) rainbowHP=v end})

SubPersonal:AddLabel("Box"):AddColorPicker("BoxTop",{Default=boxTopColor,Callback=function(c) boxTopColor=c end}):AddColorPicker("BoxBot",{Default=boxBotColor,Callback=function(c) boxBotColor=c end})
SubPersonal:AddLabel("Nametag"):AddColorPicker("Nametag",{Default=nameColor,Callback=function(c) nameColor=c end})
SubPersonal:AddLabel("HP"):AddColorPicker("HPTop",{Default=hpTopColor,Callback=function(c) hpTopColor=c end}):AddColorPicker("HPBot",{Default=hpBotColor,Callback=function(c) hpBotColor=c end})
SubPersonal:AddDropdown("HPFlagPos",{Values={"Following","Top Left"},Default=1,Text="HP Flag Pos",Callback=function(v) hpFlagPosition=v end})

ChamData = {}

ChamsEnabled = false
HighlightOn = true
BoxesOn = false
GlowOn = false
FillTrans = 0.5
OutlineTrans = 0
FillColor = Color3.fromRGB(255,255,255)
OutlineColor = Color3.fromRGB(255,255,255)
GlowColor = Color3.fromRGB(255,255,255)
GlowIntensity = 25

Limbs = {"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand",
               "RightUpperArm","RightLowerArm","RightHand","LeftUpperLeg","LeftLowerLeg",
               "LeftFoot","RightUpperLeg","RightLowerLeg","RightFoot"}

function UpdateChamsForAll()
    for plr, data in pairs(ChamData) do
        if data.Highlight then
            data.Highlight.Enabled = ChamsEnabled and HighlightOn
            data.Highlight.FillColor = FillColor
            data.Highlight.OutlineColor = OutlineColor
            data.Highlight.FillTransparency = FillTrans
            data.Highlight.OutlineTransparency = OutlineTrans
        end

        if data.Box then
            for _, box in pairs(data.Box) do
                box.Visible = ChamsEnabled and BoxesOn
                box.Color3 = FillColor
                box.Transparency = FillTrans
            end
        end

        if data.Glow then
            for _, g in pairs(data.Glow) do
                g.Ador.Visible = ChamsEnabled and GlowOn
                local r = math.floor(GlowColor.R*255 * (1 + (GlowIntensity-1)*9/99))
                local g_val = math.floor(GlowColor.G*255 * (1 + (GlowIntensity-1)*9/99))
                local b = math.floor(GlowColor.B*255 * (1 + (GlowIntensity-1)*9/99))
                g.Ador.Color3 = Color3.fromRGB(r, g_val, b)
            end
        end
    end
end

local ChamsToggle = SubChams:AddToggle("Chams", {Text="Enable Chams", Default=false, Callback=function(val)
    ChamsEnabled = val
    UpdateChamsForAll()
end})

local HighlightToggle = SubChamsPersonal:AddToggle("HighlightToggle", {Text="Highlight", Default=true, Callback=function(val)
    HighlightOn = val
    UpdateChamsForAll()
end})

local BoxesToggle = SubChamsPersonal:AddToggle("BoxesToggle", {Text="Boxes", Default=false, Callback=function(val)
    BoxesOn = val
    UpdateChamsForAll()
end})

local GlowToggle = SubChamsPersonal:AddToggle("GlowToggle", {Text="Glow", Default=false, Callback=function(val)
    GlowOn = val
    UpdateChamsForAll()
end})

local FillSlider = SubChams:AddSlider("FillTrans", {Text="Fill Transparency", Default=FillTrans, Min=0, Max=1, Rounding=2, Callback=function(val)
    FillTrans = val
    UpdateChamsForAll()
end})

local OutlineSlider = SubChams:AddSlider("OutlineTrans", {Text="Outline Transparency", Default=OutlineTrans, Min=0, Max=1, Rounding=2, Callback=function(val)
    OutlineTrans = val
    UpdateChamsForAll()
end})

local GlowSlider = SubChamsPersonal:AddSlider("GlowIntensity", {Text="Glow Intensity", Default=GlowIntensity, Min=1, Max=10, Rounding=2, Callback=function(val)
    GlowIntensity = val
    UpdateChamsForAll()
end})

local FillColorPicker = SubChamsPersonal:AddLabel("Fill Color"):AddColorPicker("FillColor", {Default=FillColor, Transparency=0, Callback=function(val)
    FillColor = val or Color3.fromRGB(255,255,255)
    UpdateChamsForAll()
end})

local OutlineColorPicker = SubChamsPersonal:AddLabel("Outline Color"):AddColorPicker("OutlineColor", {Default=OutlineColor, Transparency=0, Callback=function(val)
    OutlineColor = val or Color3.fromRGB(255,255,255)
    UpdateChamsForAll()
end})

local GlowColorPicker = SubChamsPersonal:AddLabel("Glow Color"):AddColorPicker("GlowColor", {Default=GlowColor, Transparency=0, Callback=function(val)
    GlowColor = val or Color3.fromRGB(255,255,255)
    UpdateChamsForAll()
end})


local combatl = files.gca("combat.png", "images")
Combat = Window:AddTab('Combat', combatl)
local CombatTabbox = Combat:AddLeftTabbox()
local CombatTab = CombatTabbox:AddTab('Targetting')

CombatTab:AddToggle('EnableTargeting', {
    Text = 'Targeting | REQUIRED',
    Default = targeting_flags.enabled,
    Callback = function(v)
        targeting_flags.enabled = v
        fov.Visible = v
    end
})

CombatTab:AddToggle('EnableMI', {
    Text = 'Target MI24V',
    Default = targeting_flags.mitarget,
    Callback = function(v)
        targeting_flags.enabled = v
        fov.Visible = v
    end
})

CombatTab:AddSlider('FOVRadius', {
    Text = 'FOV Radius',
    Default = targeting_flags.fov_radius,
    Min = 50,
    Max = 1000,
    Rounding = 1,
    Callback = function(v)
        targeting_flags.fov_radius = v
        fov.Size = UDim2.new(0, v, 0, v)
    end
})

CombatTab:AddSlider('GradientRotation', {
    Text = 'Gradient Rotation',
    Default = targeting_flags.gradient_rot,
    Min = 0,
    Max = 360,
    Rounding = 0,
    Callback = function(v)
        targeting_flags.gradient_rot = v
        gradient.Rotation = v
    end
})

PersonalTab = CombatTabbox:AddTab('Personalisation')

local collb = PersonalTab:AddLabel('Colors')

collb:AddColorPicker('GradientA', {
    Title = 'Gradient Color A',
    Default = targeting_flags.col_a,
    Callback = function(v)
        targeting_flags.col_a = v
        gradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, targeting_flags.col_a),
            ColorSequenceKeypoint.new(1, targeting_flags.col_b)
        }
    end
})

collb:AddColorPicker('GradientB', {
    Title = 'Gradient Color B',
    Default = targeting_flags.col_b,
    Callback = function(v)
        targeting_flags.col_b = v
        gradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, targeting_flags.col_a),
            ColorSequenceKeypoint.new(1, targeting_flags.col_b)
        }
    end
})

PersonalTab:AddToggle('RenderInner', {
    Text = 'Render Inner Stroke',
    Default = targeting_flags.render_inner,
    Callback = function(v)
        targeting_flags.render_inner = v
        stroke_inner.Transparency = v and 0 or 1
    end
})

PersonalTab:AddToggle('RenderMiddle', {
    Text = 'Render Middle Stroke',
    Default = targeting_flags.render_middle,
    Callback = function(v)
        targeting_flags.render_middle = v
        fillStroke.Transparency = v and 0 or 1
    end
})

PersonalTab:AddToggle('RenderOutline', {
    Text = 'Render Outline Stroke',
    Default = targeting_flags.render_outline,
    Callback = function(v)
        targeting_flags.render_outline = v
        outlineStroke.Transparency = v and 0 or 1
    end
})

GunMods = Combat:AddLeftGroupbox("Gunmods")

local env = getgenv()
env.RapidFireDelay = env.RapidFireDelay or 0.01

GunMods:AddSlider("ForceHitDelay", {
    Text = "Forcehit Delay",
    Default = 0.01,
    Min = 0,
    Max = 0.05,
    Rounding = 3,
    Tooltip = "Time in seconds between shots. Lower = faster hits.",
    Callback = function(v)
        env.RapidFireDelay = v
    end
})

GunMods:AddLabel("Forcehit Key"):AddKeyPicker("ForceHitBind", {
    Default = "None",
    SyncToggleState = false,
    Mode = "Hold",
    Text = "forcehit",
    Tooltip = "RISKY \nHold this key to instantly hit your target, shoots its own bullet and instantly calls inflict."
})

local ForceHitBindObj = Options.ForceHitBind

RS = game:GetService("RunService")
ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local FireProjectile = Remotes:WaitForChild("FireProjectile")
local ProjectileInflict = Remotes:WaitForChild("ProjectileInflict")

local Camera = workspace.CurrentCamera
local ClansFolder = ReplicatedStorage:WaitForChild("Clans")

local function getTeammates()
    if not env.TeamCheckEnabled then return {} end
    local teammates = {}
    for _, clan in pairs(ClansFolder:GetChildren()) do
        if clan:IsA("Folder") then
            local owner = clan:GetAttribute("Owner")
            if owner then
                if owner == LocalPlayer.Name then
                    for _, child in pairs(clan:GetChildren()) do
                        teammates[child.Name] = true
                    end
                else
                    for _, child in pairs(clan:GetChildren()) do
                        if child:IsA("Folder") and child.Name == LocalPlayer.Name then
                            teammates[owner] = true
                            for _, c in pairs(clan:GetChildren()) do
                                teammates[c.Name] = true
                            end
                            break
                        end
                    end
                end
            end
        end
    end
    return teammates
end

local function getTargetPosition()
    if not plr_target then return nil end
    return plr_target.Position
end

local function getItemRoot()
    local vm = workspace.Camera:FindFirstChild("ViewModel")
    if not vm then return nil end
    local item = vm:FindFirstChild("Item")
    if not item then return nil end
    return item.PrimaryPart, item
end

local lastShot = 0
RS.RenderStepped:Connect(function()
    if not ForceHitBindObj:GetState() then return end
    local now = tick()
    if now - lastShot < env.RapidFireDelay then return end
    lastShot = now

    local targetPos = getTargetPosition()
    if not targetPos then return end

    local itemRoot, itemModel = getItemRoot()
    if not itemRoot then return end

    itemRoot.CFrame = CFrame.lookAt(itemRoot.Position, targetPos)
    local shotId = math.random(-10000, 10000)

    FireProjectile:InvokeServer(Vector3.new(0/0,0/0,0/0), shotId, lastShot)
    ProjectileInflict:FireServer(plr_target, CFrame.new(targetPos), shotId, 0/0)
end)





GunMods:AddToggle("NoRecoilToggle", {
    Text = "No Recoil",
    Default = false,
    Tooltip = "Removes weapon recoil.",
    Callback = function(enabled)
        local char = LocalPlayer.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                if enabled then
                    if hrp:GetAttribute("OriginalRecoil") == nil then
                        hrp:SetAttribute("OriginalRecoil", hrp:GetAttribute("Recoil") or 1)
                    end
                    hrp:SetAttribute("Recoil", 0)
                else
                    local original = hrp:GetAttribute("OriginalRecoil") or 1
                    hrp:SetAttribute("Recoil", original)
                end
            end
        end
    end
})

local RepStorage = game:GetService("ReplicatedStorage")
local items = RepStorage:WaitForChild("ItemsList")

local gunModules = {}
local gunSettingsModules = {}
local ammoTypes = RepStorage:WaitForChild("AmmoTypes")
local originals = {}
local originalFireRates = {}
local originalAmmoStats = {}
local cached = false

local function cacheModules()
	if cached then return end
	table.clear(gunModules)
	table.clear(gunSettingsModules)
	table.clear(originals)
	table.clear(originalFireRates)

	for _, v in ipairs(items:GetDescendants()) do
		if v:IsA("ModuleScript") and v.Name == "SettingsModule" then
			local ok, mod = pcall(require, v)
			if ok and type(mod) == "table" then
				table.insert(gunModules, mod)
				originals[mod] = {
					TouchWallPosY = mod.TouchWallPosY,
					TouchWallPosZ = mod.TouchWallPosZ,
					TouchWallRotX = mod.TouchWallRotX,
					TouchWallRotY = mod.TouchWallRotY,
					AimInSpeed = mod.AimInSpeed,
					AimOutSpeed = mod.AimOutSpeed,
					FireModes = mod.FireModes,
					FireRate = mod.FireRate
				}
				table.insert(gunSettingsModules, mod)
				originalFireRates[mod] = mod.FireRate
			end
		end
	end

	for _, ammo in ipairs(ammoTypes:GetChildren()) do
		originalAmmoStats[ammo] = {
			AccuracyDeviation = ammo:GetAttribute("AccuracyDeviation"),
			ProjectileDrop = ammo:GetAttribute("ProjectileDrop")
		}
	end

	cached = true
end

cacheModules()

states = {
	noSway = false,
	noObstructions = false,
	instantAim = false,
	unlockFireModes = false,
	rpmBoost = false,
	nospread = false,
	nodrop = false,
	instantEquip = false,
	rpmInterval = 0.05
}

local function applyNoSway()
	for _, mod in ipairs(gunModules) do
		if states.noSway and mod.updateClient then
			local old_update = mod.updateClient
			mod.updateClient = function(a1,a2,a3)
				local r1,r2,r3 = old_update(a1,a2,a3)
				if states.noSway and a1 and a1.springs then
					for _, spring in pairs(a1.springs) do
						if spring.Position then spring.Position = Vector3.new() end
						if spring.Speed then spring.Speed = 0 end
					end
				end
				return r1,r2,r3
			end
		end
	end
end

local function applyNoObstructions()
	if not states.noObstructions then return end
	for _, mod in ipairs(gunModules) do
		pcall(function()
			mod.TouchWallPosY = 0.001
			mod.TouchWallPosZ = 0.001
			mod.TouchWallRotX = 0.001
			mod.TouchWallRotY = 0.001
		end)
	end
end

local function restoreNoObstructions()
	for mod, data in pairs(originals) do
		pcall(function()
			mod.TouchWallPosY = data.TouchWallPosY
			mod.TouchWallPosZ = data.TouchWallPosZ
			mod.TouchWallRotX = data.TouchWallRotX
			mod.TouchWallRotY = data.TouchWallRotY
		end)
	end
end

local function applyInstantAim()
	for _, mod in ipairs(gunModules) do
		if states.instantAim then
			pcall(function()
				mod.AimInSpeed = 0
				mod.AimOutSpeed = 0
			end)
		end
	end
end

local function restoreInstantAim()
	for mod, data in pairs(originals) do
		pcall(function()
			mod.AimInSpeed = data.AimInSpeed
			mod.AimOutSpeed = data.AimOutSpeed
		end)
	end
end

local function applyUnlockFireModes()
	if not states.unlockFireModes then return end
	for _, mod in ipairs(gunModules) do
		pcall(function()
			mod.FireModes = { "Auto", "Semi" }
		end)
	end
end

local function restoreUnlockFireModes()
	for mod, data in pairs(originals) do
		if data.FireModes then
			pcall(function()
				mod.FireModes = data.FireModes
			end)
		end
	end
end

local function applyFireRate()
	if not states.rpmBoost then return end
	for _, mod in ipairs(gunSettingsModules) do
		pcall(function()
			mod.FireRate = states.rpmInterval
		end)
	end
end

local function restoreFireRate()
	for mod, rate in pairs(originalFireRates) do
		pcall(function()
			mod.FireRate = rate
		end)
	end
end

local function applyAmmoMods()
	for _, ammo in ipairs(ammoTypes:GetChildren()) do
		local stats = originalAmmoStats[ammo]
		if stats then
			if states.nospread then ammo:SetAttribute("AccuracyDeviation", 0) else ammo:SetAttribute("AccuracyDeviation", stats.AccuracyDeviation) end
			if states.nodrop then ammo:SetAttribute("ProjectileDrop", 0) else ammo:SetAttribute("ProjectileDrop", stats.ProjectileDrop) end
		end
	end
end


GunMods:AddToggle("no_sway", { Text = "No Sway", Default = false, Callback = function(v) states.noSway = v; applyNoSway() end })
GunMods:AddToggle("no_obstructions", { Text = "No Obstructions", Default = false, Callback = function(v) states.noObstructions = v; if v then applyNoObstructions() else restoreNoObstructions() end end })
GunMods:AddToggle("instant_aim", { Text = "Instant Aim", Default = false, Callback = function(v) states.instantAim = v; if v then applyInstantAim() else restoreInstantAim() end end })
GunMods:AddToggle("unlock_firemodes", { Text = "Unlock Firemodes", Default = false, Callback = function(v) states.unlockFireModes = v; if v then applyUnlockFireModes() else restoreUnlockFireModes() end end })
GunMods:AddToggle("rpm_toggle", { Text = "Override firerate", Default = false, Callback = function(v) states.rpmBoost = v; if v then applyFireRate() else restoreFireRate() end end })
GunMods:AddSlider("rpm_slider", { Text = "Firerate", Default = 0.05, Min = 0, Max = 0.1, Rounding = 3, Callback = function(v) states.rpmInterval = v; if states.rpmBoost then applyFireRate() end end })
GunMods:AddToggle("nospread", { Text = "No Spread", Default = false, Callback = function(v) states.nospread = v; applyAmmoMods() end })
GunMods:AddToggle("nodrop", { Text = "No Drop", Default = false, Callback = function(v) states.nodrop = v; applyAmmoMods() end })
GunMods:AddToggle("InstantEquip", { Text = "Instant Equip", Default = false, Callback = function(v) states.instantEquip = v end })

task.spawn(function()
	while true do
		task.wait(0.001)
		if Library.Unloaded then break end
		if not states.instantEquip then continue end

		local viewModel = workspace:FindFirstChild("Camera")
		if viewModel then viewModel = viewModel:FindFirstChild("ViewModel") end
		if not viewModel then continue end

		local animator = viewModel:FindFirstChildOfClass("Humanoid"):FindFirstChild("Animator")
		if not animator then continue end

		for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
			local anim = track.Animation
			if anim and anim.Name == "Equip" then
				track:AdjustSpeed(15)
				track.TimePosition = track.Length - 0.01
			end
		end
	end
end)

ammoTypes.ChildAdded:Connect(function()
	task.wait()
	applyAmmoMods()
end)


getgenv().silent_aim = {
    enabled = false,
    instant = false,
    tracer = false,
    target_part = nil
}

local LeftGroupBox = Combat:AddRightGroupbox("Silent Aim")

LeftGroupBox:AddToggle("SilentAimEnabled", {
    Text = "Silent Aim",
    Default = false,
    Tooltip = "Xeno/Solara do not support this function. | Toggle silent aim on/off",
    Callback = function(value)
        silent_aim.enabled = value
    end
})

LeftGroupBox:AddToggle("InstantHit", {
    Text = "Instant Hit",
    Default = false,
    Tooltip = "Xeno/Solara do not support this function. | Bullets hit instantly",
    Callback = function(value)
        silent_aim.instant = value
    end
})

local hitmarkerColor = Color3.fromRGB(255, 255, 255)

local TracerGroup = Combat:AddRightGroupbox("FX")

local ws = workspace
local RunService = game:GetService("RunService")
local Camera = ws:WaitForChild("Camera")

local EnableTracers = TracerGroup:AddToggle("EnableTracers", {
    Text = "Bullet Tracers",
    Default = false,
    Tooltip = "Toggle bullet tracers on/off",
})

local TracerColorStart = EnableTracers:AddColorPicker("TracerColorStart", {
    Default = Color3.fromRGB(255, 80, 80),
    Title = "Start Color",
})

local TracerColorEnd = EnableTracers:AddColorPicker("TracerColorEnd", {
    Default = Color3.fromRGB(255, 255, 80),
    Title = "End Color",
})

local textures = {
    Neon = "rbxassetid://90961491521758",
    Lightning = "rbxassetid://247707396",
    ["Tiny Lightning"] = "rbxassetid://7151778302",
    Wave = "rbxassetid://123453630521207",
    Beam = "rbxassetid://6376702661",
}

local TracerTexture = TracerGroup:AddDropdown("TracerTexture", {
    Values = {"Neon","Lightning","Tiny Lightning","Wave","Beam"},
    Default = "Neon",
    Multi = false,
    Text = "Tracer Texture",
    Tooltip = "Select your tracer texture",
})

local TracerWidth = TracerGroup:AddSlider("TracerWidth", {Text = "Tracer Width", Default = 0.08, Min = 0.01, Max = 1, Rounding = 2})
local TracerLifetime = TracerGroup:AddSlider("TracerLifetime", {Text = "Tracer Lifetime", Default = 0.25, Min = 0.05, Max = 2, Rounding = 2})
local TracerFade = TracerGroup:AddSlider("TracerFade", {Text = "Tracer Fadeout", Default = 0.25, Min = 0.05, Max = 2, Rounding = 2})

local rayParams = RaycastParams.new()
rayParams.FilterType = Enum.RaycastFilterType.Exclude
rayParams.IgnoreWater = true
rayParams.FilterDescendantsInstances = {ws:FindFirstChild("NoCollision"), Camera}

local function createBeam(origin, target)
    if not EnableTracers.Value then return end

    -- grab colors safely
    local startColor = TracerColorStart.Value
    if typeof(startColor) ~= "Color3" then
        startColor = Color3.fromRGB(255, 80, 80)
    end

    local endColor = TracerColorEnd.Value
    if typeof(endColor) ~= "Color3" then
        endColor = startColor
    end

    local texture = textures[TracerTexture.Value] or textures.Neon
    local width = TracerWidth.Value
    local lifetime = TracerLifetime.Value
    local fadeout = TracerFade.Value

    -- parts
    local p1 = Instance.new("Part", ws)
    local p2 = Instance.new("Part", ws)
    p1.Position = origin
    p2.Position = target
    p1.Anchored = true
    p2.Anchored = true
    p1.CanCollide = false
    p2.CanCollide = false
    p1.Size = Vector3.zero
    p2.Size = Vector3.zero
    p1.Transparency = 1
    p2.Transparency = 1

    local a1 = Instance.new("Attachment", p1)
    local a2 = Instance.new("Attachment", p2)

    -- beam
    local beam = Instance.new("Beam", ws)
    beam.Attachment0 = a1
    beam.Attachment1 = a2

    -- **always pass a table of ColorSequenceKeypoints**
    beam.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, startColor),
        ColorSequenceKeypoint.new(1, endColor)
    })

    beam.LightEmission = 1
    beam.LightInfluence = 1
    beam.TextureMode = Enum.TextureMode.Static
    beam.Texture = texture
    beam.FaceCamera = true
    beam.Width0 = width
    beam.Width1 = width
    beam.Segments = 1
    beam.Transparency = NumberSequence.new(0)

    local startTime = tick()
    local conn
    conn = RunService.RenderStepped:Connect(function()
        local elapsed = tick() - startTime
        local alpha = math.clamp(elapsed / fadeout, 0, 1)
        beam.Transparency = NumberSequence.new(alpha)
        if elapsed >= lifetime then
            conn:Disconnect()
            p1:Destroy()
            p2:Destroy()
            beam:Destroy()
        end
    end)
end

local function watchItem(item)
    if not item then return end
    local barrel = item:FindFirstChild("Barrel")
    if not barrel then return end

    barrel.ChildAdded:Connect(function(child)
        if child.Name:lower() == "smoke" then
            local origin = barrel.Position
            local direction = barrel.CFrame.LookVector * 1000
            local result = ws:Raycast(origin, direction, rayParams)
            local hitPos = result and result.Position or (origin + direction)
            createBeam(origin, hitPos)
        end
    end)
end

local function watchViewModel(vm)
    if not vm then return end
    local function attachItem(item) watchItem(item) end

    local item = vm:FindFirstChild("Item")
    if item then attachItem(item) end

    vm.ChildAdded:Connect(function(child)
        if child.Name:lower() == "item" then attachItem(child) end
    end)
end

if Camera:FindFirstChild("ViewModel") then
    watchViewModel(Camera.ViewModel)
end

Camera.ChildAdded:Connect(function(child)
    if child.Name:lower() == "viewmodel" then
        watchViewModel(child)
    end
end)



local playerl = files.gca("player.png", "images")
Plr = Window:AddTab('Player', playerl)
local SpeedTab = Plr:AddLeftGroupbox("Speed")
local BypassTab = Plr:AddRightGroupbox("Bypass")

speedState = {
    enabled = false,
    key = "None",
    speed = 1,
    type = "Walkspeed"
}
local toggleObj = SpeedTab:AddToggle("speed_toggle", { Text = "Speedhack", Default = false })
local keypickerLabel = toggleObj:AddKeyPicker("speed_keypicker", { Text = "Speedhack", Default = "None", Mode = "Toggle" })
local sliderObj = SpeedTab:AddSlider("speed_value", { Text = "Speed Value", Default = 1, Min = 0, Max = 1.5, Rounding = 1 })
local dropdownObj = SpeedTab:AddDropdown("speed_type", { Text = "Speedhack Type", Values = { "Walkspeed", "CFrame", "TranslateBy" }, Default = 1 })
    

BypassTab:AddToggle('NoFallToggle', {
    Text = 'Bypass Fall',
    Default = false,
    Tooltip = 'prevent fall damage üëâüëàü•πü•πü•πü•πüòùüòùüòù'
})
task.wait()

keyObj = Options.speed_keypicker
toggleFlag = Toggles.speed_toggle
sliderFlag = Options.speed_value
dropdownFlag = Options.speed_type

toggleFlag:OnChanged(function(v) speedState.enabled = v end)
keyObj:OnChanged(function(k) speedState.key = k end)
sliderFlag:OnChanged(function(v) speedState.speed = v end)
dropdownFlag:OnChanged(function(v) speedState.type = v end)

local CamTab = Plr:AddRightGroupbox('Camera')

CamTab:AddToggle("OverrideVM",{
    Text="Override Viewmodel",
    Default=false,
    Callback=function(v) overrideVM=v end
})

CamTab:AddToggle("OverrideArms",{
    Text="Override Arms",
    Default=false,
    Callback=function(v) overrideArms=v end
}):AddColorPicker("ArmsColor",{
    Default=armsColor,
    Callback=function(v) armsColor=v end
})

CamTab:AddDropdown("ArmsMat",{
    Text="Arms Material",
    Values={"Neon","ForceField","SmoothPlastic"},
    Default=3,
    Callback=function(v) armsMat=Enum.Material[v] end
})

CamTab:AddSlider("ArmsTrans",{
    Text="Arms Transparency",
    Min=0, Max=1, Default=0, Rounding=2,
    Callback=function(v) armsTrans=v end
})

CamTab:AddToggle("OverrideWeapon",{
    Text="Override Weapon",
    Default=false,
    Callback=function(v) overrideWeapon=v end
}):AddColorPicker("WeaponColor",{
    Default=weaponColor,
    Callback=function(v) weaponColor=v end
})

CamTab:AddDropdown("WeaponMat",{
    Text="Weapon Material",
    Values={"Neon","ForceField","SmoothPlastic"},
    Default=3,
    Callback=function(v) weaponMat=Enum.Material[v] end
})

CamTab:AddSlider("WeaponTrans",{
    Text="Weapon Transparency",
    Min=0, Max=1, Default=0, Rounding=2,
    Callback=function(v) weaponTrans=v end
})

local vmhighlightt = CamTab:AddToggle("VMHighlight",{
    Text="Apply Highlight",
    Default=false,
    Callback=function(v) hlEnabled=v end
}):AddColorPicker("HLFill",{
    Default=highlightFill,
    Callback=function(v) highlightFill=v end
})

vmhighlightt:AddColorPicker("HLOutline",{
    Default=highlightOutline,
    Callback=function(v) highlightOutline=v end
})

CamTab:AddSlider("HLFillTrans",{
    Text="Highlight Fill Transparency",
    Min=-20, Max=20, Default=0, Rounding=1,
    Callback=function(v) hlFillTrans=v end
})

CamTab:AddSlider("HLOutlineTrans",{
    Text="Highlight Outline Transparency",
    Min=0, Max=1, Default=0, Rounding=2,
    Callback=function(v) hlOutlineTrans=v end
})

CamTab:AddDivider()
local fovToggle = CamTab:AddToggle("FOVOverride", {Text = "FOV Override", Default = false})
local fovSlider = CamTab:AddSlider("FOVValue", {Text = "FOV Override Value", Default = 120, Min = 90, Max = 120, Rounding = 1})

local zoomToggle = CamTab:AddToggle("ZoomOverride", {Text = "Zoom FOV Override", Default = false})
zoomToggle:AddKeyPicker("ZoomKey", {Text = "Zoom Key", Default = "None", Mode = "Toggle"})
local zoomSlider = CamTab:AddSlider("ZoomFOV", {Text = "Zoom FOV Value", Default = 10, Min = 1, Max = 70, Rounding = 1})

local Camera = workspace.CurrentCamera
zoomKeyObj = Options.ZoomKey

task.spawn(function()
    local RunService = game:GetService("RunService")
    while true do
        RunService.RenderStepped:Wait()
        if Library.Unloaded then break end

        local zooming = zoomToggle.Value and zoomKeyObj and zoomKeyObj:GetState()

        if zooming then
            Camera.FieldOfView = Options.ZoomFOV.Value
        elseif fovToggle.Value then
            Camera.FieldOfView = Options.FOVValue.Value
        else
            Camera.FieldOfView = 90
        end
    end
end)


game:GetService("RunService").RenderStepped:Connect(updateFOV)
print('\n')
print('\n')
print('\n')
print('loading \n')

end)
registerFuncAuto(function()
notifyl("ui","plr")

local USettings = Window:AddTab("UI Settings", "settings")
local MenuGroup = USettings:AddLeftGroupbox("Menu", "wrench")
MenuGroup:AddToggle("KeybindMenuOpen", {
	Default = Library.KeybindFrame.Visible,
	Text = "Open Keybind Menu",
	Callback = function(value)
		Library.KeybindFrame.Visible = value
	end,
})
MenuGroup:AddToggle("ShowCustomCursor", {
	Text = "Custom Cursor",
	Default = true,
	Callback = function(Value)
		Library.ShowCustomCursor = Value
	end,
})
MenuGroup:AddDropdown("NotificationSide", {
	Values = { "Left", "Right" },
	Default = "Right",

	Text = "Notification Side",

	Callback = function(Value)
		Library:SetNotifySide(Value)
	end,
})
MenuGroup:AddDropdown("DPIDropdown", {
	Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
	Default = "100%",

	Text = "DPI Scale",

	Callback = function(Value)
		Value = Value:gsub("%%", "")
		local DPI = tonumber(Value)

		Library:SetDPIScale(DPI)
	end,
})
MenuGroup:AddLabel("Menu bind")
	:AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('SOLUTIONS')
SaveManager:SetFolder('SOLUTIONS/configs')
SaveManager:BuildConfigSection(USettings)
ThemeManager:ApplyToTab(USettings)
SaveManager:LoadAutoloadConfig()



end)
registerFuncAuto(function()
notifyl("ui","managers")





_G.showHitmarker = function(pos)
    local hitpart = Instance.new("Part")
    hitpart.Name = "HitmarkerPart"
    hitpart.Transparency = 1
    hitpart.CanCollide = false
    hitpart.CanQuery = false
    hitpart.Size = Vector3.new(0.01, 0.01, 0.01)
    hitpart.Anchored = true
    hitpart.Position = pos
    hitpart.Parent = workspace:FindFirstChild("NoCollision")

    local hit = Instance.new("BillboardGui")
    hit.Name = "hit"
    hit.AlwaysOnTop = true
    hit.Size = UDim2.new(0, 80, 0, 80) 
    hit.StudsOffset = Vector3.new(0, 0, 0)
    hit.Parent = hitpart

    local hit_img = Instance.new("ImageLabel")
    hit_img.Name = "hit_img"
    hit_img.Image = "http://www.roblox.com/asset/?id=13298929624"
    hit_img.BackgroundTransparency = 1
    hit_img.Size = UDim2.new(0, 80, 0, 80) 
    hit_img.Visible = true
    hit_img.ImageColor3 = hitmarkerColor
    hit_img.Rotation = 45
    hit_img.AnchorPoint = Vector2.new(0.5, 0.5)
    hit_img.Position = UDim2.new(0.5, 0, 0.5, 0)
    hit_img.Parent = hit

    task.spawn(function()
        local ts = game:GetService("TweenService")
        ts:Create(hit_img, TweenInfo.new(2, Enum.EasingStyle.Sine), {ImageTransparency = 1}):Play()
        ts:Create(hit_img, TweenInfo.new(2, Enum.EasingStyle.Linear), {Rotation = 180}):Play()
        task.wait(_G.HitmarkerFade)
        if hitpart then hitpart:Destroy() end
    end)
end

local TweenService = game:GetService("TweenService")

pcall(function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local CurrentCamera = workspace.CurrentCamera

    local BulletModule = require(ReplicatedStorage.Modules.FPS.Bullet)
    local OriginalCreateBullet = BulletModule.CreateBullet

    local function resolveTarget()
        if not plr_target then return nil end
        return plr_target
    end

    local function resolveTargetPosition()
        if not plr_target then return nil end
        return plr_target.Position
    end

    local function predictVelocity(origin, destination, velocity, speed)
        local displacement = destination - origin
        local a = velocity:Dot(velocity) - speed * speed
        local b = 2 * displacement:Dot(velocity)
        local c = displacement:Dot(displacement)

        local disc = b*b - 4*a*c
        if disc < 0 then return destination end

        local t0 = (-b - math.sqrt(disc)) / (2*a)
        local t1 = (-b + math.sqrt(disc)) / (2*a)
        local t = math.max(t0, t1)
        if t < 0 then t = math.min(t0, t1) end
        if t < 0 then t = 0 end

        return destination + velocity * t
    end

    BulletModule.CreateBullet = newcclosure(function(...)
        local args = {...}
        if silent_aim.enabled and plr_target then
            local targetPart = resolveTarget()
            local targetPos = resolveTargetPosition()
            if targetPart and targetPos then
                silent_aim.target_part = targetPart

                local loadedammo = nil
                pcall(function()
                    local weapon = get_local_weapon()
                    local inv_weapon = LocalPlayer and LocalPlayer.Backpack:FindFirstChild(weapon)
                    if inv_weapon then
                        local magazine = inv_weapon:FindFirstChild("Attachments") and inv_weapon.Attachments:FindFirstChild("Magazine")
                        if magazine then
                            loadedammo = magazine.ItemProperties:FindFirstChild("LoadedAmmo") and magazine.ItemProperties.LoadedAmmo:FindFirstChildOfClass("Folder")
                        end
                    end
                end)

                local ProjectileSpeed = loadedammo and loadedammo:GetAttribute("MuzzleVelocity") or 300
                if type(args[5]) ~= "table" then args[5] = {} end
                args[5].CFrame = CFrame.new(
                    CurrentCamera.CFrame.Position,
                    predictVelocity(CurrentCamera.CFrame.Position, targetPos, targetPart.Velocity or Vector3.new(), ProjectileSpeed)
                )

                if silent_aim.tracer then
                    print("tracer placeholder")
                end
                if silent_aim.hitmarkers and typeof(showHitmarker) == "function" then
                    print("hitmarker placeholder")
                end
            else
                silent_aim.target_part = nil
            end
        else
            silent_aim.target_part = nil
        end

        return OriginalCreateBullet(table.unpack(args))
    end)
end)




end)
registerFuncAuto(function()
notifyl("logic","silent")


task.spawn(function()
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local originalWalkSpeed = 19.2

    RunService.RenderStepped:Connect(function(dt)
        if Library.Unloaded then return end
        if not speedState.enabled then return end
        if not keyObj:GetState() then return end

        local char = LocalPlayer.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not char or not hum or not hrp then return end

        local speed = sliderFlag.Value
        local typeChoice = dropdownFlag.Value

        if typeChoice == "Walkspeed" then
            hum.WalkSpeed = 16 * speed
        elseif typeChoice == "CFrame" then
            local dir = hum.MoveDirection
            if dir.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + dir * speed * dt * 20
            end
        elseif typeChoice == "TranslateBy" then
            local dir = hum.MoveDirection
            if dir.Magnitude > 0 then
                hrp:TranslateBy(dir * speed * dt * 10)
            end
        end
    end)
end)


local NoFallEnabled = false
Toggles.NoFallToggle:OnChanged(function(Value)
    NoFallEnabled = Value
end)

local player = game:GetService("Players").LocalPlayer
local character = player.Character
local humanoid = character:FindFirstChildOfClass('Humanoid')
local rootPart = character:FindFirstChild('HumanoidRootPart')
RunService = game:GetService("RunService")
RunService.Heartbeat:Connect(function()
    if not NoFallEnabled then return end

    if not character then return end
    if not humanoid or not rootPart then return end

    local state = humanoid:GetState()
    if state == Enum.HumanoidStateType.Freefall then
        local velY = rootPart.AssemblyLinearVelocity.Y
        if velY < -12.5 then
            humanoid:ChangeState(Enum.HumanoidStateType.Landed)
        end
    end
end)

pcall(function() local plr=game.Players.LocalPlayer local ws=game:GetService("Workspace") local function h() local c=plr.Character local hum=c and c:FindFirstChild("Humanoid") if not hum then c=plr.CharacterAdded:Wait() hum=c:WaitForChild("Humanoid") end return hum end local hum=h() local conns={{'CharacterController',hum:GetPropertyChangedSignal('WalkSpeed')},{'CharacterController',hum:GetPropertyChangedSignal('JumpHeight')},{'CharacterController',hum:GetPropertyChangedSignal('HipHeight')},{'CharacterController',ws:GetPropertyChangedSignal('Gravity')},{'CharacterController',hum.StateChanged},{'CharacterController',hum.ChildAdded},{'CharacterController',hum.ChildRemoved}} local function d() for _,arr in ipairs(conns)do for _,conn in ipairs(getconnections(arr[2]))do if type(conn.Function)=="function"then local info=debug.getinfo(conn.Function) if info and string.find(info.source,arr[1])then conn:Disable()end end end end end d() plr.CharacterAdded:Connect(function(c) hum=c:WaitForChild("Humanoid") d() end) end)
end)
registerFuncAuto(function()
notifyl("logic","speedhack")




local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local function SetupGlowForCharacter(plr, char)
    local GlowParts = {}
    local function recurse(part)
        if part:IsA("BasePart") or part:IsA("MeshPart") then
            local isLimb = false
            for _, l in pairs(Limbs) do if part.Name == l then isLimb = true break end end
            if isLimb then
                local adorn = Instance.new("BoxHandleAdornment")
                adorn.Size = part.Size
                adorn.Adornee = part
                local r = math.floor(GlowColor.R*255 * (1 + (GlowIntensity-1)*9/99))
                local g_val = math.floor(GlowColor.G*255 * (1 + (GlowIntensity-1)*9/99))
                local b = math.floor(GlowColor.B*255 * (1 + (GlowIntensity-1)*9/99))
                adorn.Color3 = Color3.fromRGB(r, g_val, b)
                adorn.ZIndex = 5
                adorn.AlwaysOnTop = false
                adorn.Visible = ChamsEnabled and GlowOn
                adorn.Parent = part

                local function hideAll(p)
                end
                hideAll(part)

                table.insert(GlowParts, {Part=part, Ador=adorn, OrigTransparency=0})
            end
        end
        for _, c in pairs(part:GetChildren()) do recurse(c) end
    end
    recurse(char)
    return GlowParts
end

local function SetupChamsForCharacter(plr, char)
    if ChamData[plr] then
        local prev = ChamData[plr]
        if prev.Highlight then prev.Highlight:Destroy() end
        if prev.Box then for _, b in pairs(prev.Box) do b:Destroy() end end
    end

    local h = Instance.new("Highlight")
    h.Adornee = char
    h.FillColor = FillColor
    h.OutlineColor = OutlineColor
    h.FillTransparency = FillTrans
    h.OutlineTransparency = OutlineTrans
    h.Enabled = ChamsEnabled and HighlightOn
    h.Parent = workspace

    local Boxes = {}
    for _, limbName in pairs(Limbs) do
        local part = char:FindFirstChild(limbName)
        if part and part:IsA("BasePart") then
            local box = Instance.new("BoxHandleAdornment")
            box.Size = part.Size
            box.Adornee = part
            box.ZIndex = 3
            box.AlwaysOnTop = true
            box.Visible = ChamsEnabled and BoxesOn
            box.Color3 = FillColor
            box.Transparency = FillTrans
            box.Parent = part
            table.insert(Boxes, box)
        end
    end

    local GlowParts = SetupGlowForCharacter(plr, char)

    ChamData[plr] = {Highlight=h, Box=Boxes, Glow=GlowParts}
    UpdateChamsForAll()
end

for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
    if plr ~= game.Players.LocalPlayer and plr.Character then
        SetupChamsForCharacter(plr, plr.Character)
    end
end

game:GetService("Players").PlayerAdded:Connect(function(plr)
    if plr ~= game.Players.LocalPlayer then
        plr.CharacterAdded:Connect(function(char)
            SetupChamsForCharacter(plr, char)
        end)
        if plr.Character then
            SetupChamsForCharacter(plr, plr.Character)
        end
    end
end)



local GlowChamsFixEnabled = false
local OriginalTransparency = {}

local function SetCharacterTransparency(char, transparency)
    if not char then return end
    if not OriginalTransparency[char] then OriginalTransparency[char] = {} end
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("MeshPart") then
            if OriginalTransparency[char][part] == nil then
                OriginalTransparency[char][part] = part.Transparency
            end
            part.Transparency = transparency
        end
    end
end

local function RestoreCharacterTransparency(char)
    if OriginalTransparency[char] then
        for part, orig in pairs(OriginalTransparency[char]) do
            if part and part.Parent then
                part.Transparency = orig
            end
        end
        OriginalTransparency[char] = nil
    end
end

local function ApplyGlowChamsFixToPlayer(plr)
    if plr.Character then
        SetCharacterTransparency(plr.Character, 0.99)
    end
    plr.CharacterAdded:Connect(function(char)
        wait()
        if GlowChamsFixEnabled then
            SetCharacterTransparency(char, 0.99)
        end
    end)
end

local GlowChamsFixToggle = SubChamsPersonal:AddToggle("GlowChamsFix", {
    Text = "Glowchams Fix",
    Default = false,
    Callback = function(val)
        GlowChamsFixEnabled = val
        for _, plr in pairs(game.Players:GetPlayers()) do
            if plr ~= game.Players.LocalPlayer then
                if GlowChamsFixEnabled then
                    ApplyGlowChamsFixToPlayer(plr)
                else
                    if plr.Character then
                        RestoreCharacterTransparency(plr.Character)
                    end
                end
            end
        end
    end
})

end)
registerFuncAuto(function()
notifyl("logic","chams")


local esp_screen=Instance.new("ScreenGui")
esp_screen.Name="ESP_Screen"
esp_screen.Parent=game:GetService("CoreGui")
esp_screen.ResetOnSpawn=false
esp_screen.IgnoreGuiInset=true
esp_screen.DisplayOrder=999999
local esp_folder=Instance.new("Folder")
esp_folder.Name="ESP_Objects"
esp_folder.Parent=esp_screen

local esp_objects={}
local STUDS_HEIGHT,STUDS_WIDTH,box_scale=5.5,4,6
local function project(pos)
 local v,onScreen=Camera:WorldToViewportPoint(pos)
 return Vector2.new(v.X,v.Y),onScreen
end

local function formatName(name)
 if casingMode=="Lowercase" then return string.lower(name)
 elseif casingMode=="Uppercase" then return string.upper(name)
 else return name end
end

Players = game:GetService("Players")
RunService = game:GetService("RunService")
Camera = workspace.CurrentCamera
LocalPlayer = Players.LocalPlayer

local function create_esp(player)
 if esp_objects[player] then return end
 local container=Instance.new("Frame")
 container.BackgroundTransparency=1
 container.BorderSizePixel=0
 container.Visible=false
 container.ZIndex=1
 container.Parent=esp_folder

 local box=Instance.new("Frame")
 box.Size=UDim2.new(1,0,1,0)
 box.BackgroundTransparency=1
 box.BorderSizePixel=0
 box.ZIndex=2
 box.Parent=container

 local stroke_outline=Instance.new("UIStroke")
 stroke_outline.Color=Color3.new(0,0,0)
 stroke_outline.Thickness=1
 stroke_outline.LineJoinMode=Enum.LineJoinMode.Miter
 stroke_outline.BorderOffset=UDim.new(0,0)
 stroke_outline.ZIndex=4
 stroke_outline.Parent=box

 local stroke_fill=Instance.new("UIStroke")
 stroke_fill.Color=Color3.new(1,1,1)
 stroke_fill.Thickness=2
 stroke_fill.LineJoinMode=Enum.LineJoinMode.Miter
 stroke_fill.BorderOffset=UDim.new(0,1)
 stroke_fill.ZIndex=2
 stroke_fill.Parent=box

 local stroke_inline=Instance.new("UIStroke")
 stroke_inline.Color=Color3.new(0,0,0)
 stroke_inline.Thickness=1
 stroke_inline.LineJoinMode=Enum.LineJoinMode.Miter
 stroke_inline.BorderOffset=UDim.new(0,2)
 stroke_inline.ZIndex=3
 stroke_inline.Parent=box

 local boxGradient=Instance.new("UIGradient")
 boxGradient.Rotation=90
 boxGradient.Color=ColorSequence.new(boxTopColor,boxBotColor)
 boxGradient.Parent=stroke_fill

 local name=Instance.new("TextLabel")
 name.AnchorPoint=Vector2.new(0.5,1)
 name.Position=UDim2.new(0.5,0,0,-4)
 name.Size=UDim2.new(1,20,0,14)
 name.BackgroundTransparency=1
 name.TextScaled=false
 name.TextSize=name_size
 name.TextColor3=nameColor
 name.FontFace=nametagFont
 name.Text=player.Name
 name.ZIndex=5
 name.Parent=container

 local nameStroke=Instance.new("UIStroke")
 nameStroke.Color=Color3.new(0,0,0)
 nameStroke.Thickness=1
 nameStroke.Parent=name

 local holder=Instance.new("Frame")
 holder.BackgroundTransparency=1
 holder.Size=UDim2.new(0,3,1,6)
 holder.AnchorPoint=Vector2.new(1,1)
 holder.Position=UDim2.new(0,-4,1,3)
 holder.ZIndex=5
 holder.Parent=container

 local healthbar=Instance.new("Frame")
 healthbar.BackgroundTransparency=1
 healthbar.Size=UDim2.new(1,-2,1,-2)
 healthbar.Position=UDim2.new(1,-2,1,-1)
 healthbar.AnchorPoint=Vector2.new(0,1)
 healthbar.ZIndex=6
 healthbar.Parent=holder

 local bar=Instance.new("Frame")
 bar.Size=UDim2.new(1,0,1,0)
 bar.Position=UDim2.new(0,0,0,0)
 bar.BackgroundColor3=Color3.new(1,1,1)
 bar.ZIndex=6
 bar.Parent=healthbar

 local barGradient=Instance.new("UIGradient")
 barGradient.Rotation=90
 barGradient.Color=ColorSequence.new(hpTopColor,hpBotColor)
 barGradient.Parent=bar

 local flag=Instance.new("TextLabel")
 flag.Size=UDim2.new(0,15,0, name_size-3)
 flag.Position=UDim2.new(0, -12,0,0)
 flag.AnchorPoint=Vector2.new(1,0)
 flag.TextSize=name_size-3
 flag.TextColor3=hpTopColor
 flag.FontFace=nametagFont
 flag.BackgroundTransparency=1
 flag.Text="100"
 flag.ZIndex=7
 flag.Parent=holder

 local flagStroke=Instance.new("UIStroke")
 flagStroke.Color=Color3.new(0,0,0)
 flagStroke.Thickness=1
 flagStroke.Parent=flag

 esp_objects[player]={container=container,box=box,fill=stroke_fill,inline=stroke_inline,outline=stroke_outline,boxGradient=boxGradient,name=name,nameStroke=nameStroke,holder=holder,healthbar=healthbar,bar=bar,barGradient=barGradient,flag=flag,flagStroke=flagStroke}
end

local function remove_esp(player)
 if esp_objects[player] then
  esp_objects[player].container:Destroy()
  esp_objects[player]=nil
 end
end

for _,p in ipairs(Players:GetPlayers()) do if p~=LocalPlayer then create_esp(p) end end
Players.PlayerAdded:Connect(function(p) if p~=LocalPlayer then create_esp(p) end end)
Players.PlayerRemoving:Connect(remove_esp)


RunService.RenderStepped:Connect(function()
    local hue = tick()%5/5
    for player, esp in pairs(esp_objects) do
        local char = player.Character
        local hum = char and char:FindFirstChild("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not (hrp and hum) then
            esp.container.Visible = false
            continue
        end

        local top = hrp.Position + Vector3.new(0, STUDS_HEIGHT/2, 0)
        local bottom = hrp.Position - Vector3.new(0, STUDS_HEIGHT/2, 0)
        local top2D, topVis = project(top)
        local bot2D, botVis = project(bottom)
        if not (topVis and botVis) then
            esp.container.Visible = false
            continue
        end

        local height = bot2D.Y - top2D.Y
        local dist = (Camera.CFrame.Position - hrp.Position).Magnitude
        local width = STUDS_WIDTH / dist * 100 * box_scale

        esp.container.Size = UDim2.new(0, width, 0, height)
        esp.container.Position = UDim2.new(0, top2D.X - width/2, 0, top2D.Y)
        esp.container.Visible = true

        if rainbowBox then
            esp.boxGradient.Color = ColorSequence.new(Color3.fromHSV(hue,1,1), Color3.fromHSV((hue+0.3)%1,1,1))
        else
            esp.boxGradient.Color = ColorSequence.new(boxTopColor, boxBotColor)
        end
        esp.fill.Transparency = 0
        esp.box.Visible = boxEspEnabled

        esp.name.TextColor3 = rainbowName and Color3.fromHSV(hue,1,1) or nameColor
        esp.name.TextSize = name_size
        esp.name.FontFace = nametagFont
        esp.name.Text = formatName(player.Name)
        esp.name.Visible = nameEspEnabled
        esp.nameStroke.Color = Color3.new(0,0,0)

        local hpPercent = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
        esp.bar.Size = UDim2.new(1, 0, hpPercent, 0)
        esp.bar.Position = UDim2.new(0, 0, 1 - hpPercent, 0)
        esp.bar.Visible = hpBarEnabled
        esp.barGradient.Color = rainbowHP and ColorSequence.new(Color3.fromHSV(hue,1,1), Color3.fromHSV((hue+0.3)%1,1,1)) or ColorSequence.new(hpTopColor, hpBotColor)

        esp.flag.Visible = hpFlagEnabled
        esp.flag.Text = tostring(math.floor(hum.Health))
        esp.flag.TextSize = name_size - 3
        esp.flag.TextColor3 = hpTopColor
        if hpFlagPosition == "Following" then
            esp.flag.Position = UDim2.new(0, -12, 1 - hpPercent, 0)
            esp.flag.AnchorPoint = Vector2.new(1, 0)
        else
            esp.flag.Position = UDim2.new(0, -12, 0, 0)
            esp.flag.AnchorPoint = Vector2.new(1, 0)
        end
    end
end)



end)
registerFuncAuto(function()
notifyl("logic","esp")

finishLoading()
end)

loadfunc()
